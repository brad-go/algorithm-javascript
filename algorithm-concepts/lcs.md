# LCS 알고리즘

LCS는 주로 **최장 공통 부분 수열(Longest Common Subsequence)**을 말하지만, **최장 공통 문자열(Longest Common Substring)**을 말하기도 한다.

문자열 ABCDEF와 GBCDFE를 이용해 차이점을 예시로 들어보면

![https://velog.velcdn.com/images%2Femplam27%2Fpost%2F14e1f11d-d3de-4dd3-8f41-3e7f9697770f%2F%EB%91%98%20%EC%B0%A8%EC%9D%B4.png](https://velog.velcdn.com/images%2Femplam27%2Fpost%2F14e1f11d-d3de-4dd3-8f41-3e7f9697770f%2F%EB%91%98%20%EC%B0%A8%EC%9D%B4.png)

해당 예시에서 **최장 공통 부분수열(Longest Common Subsequence)**은 **BCDF**, **BCDE**가 될 수 있다. 부분 수열이기 때문에 문자 사이를 건너뛰어 공통되면서 가장 긴 부분인 문자열을 찾으면 된다. **최장 공통 문자열(Longest Common Substring)**은 **BCD**이다. 부분문자열이 아니기 때문에 한번에 이어져있는 문자열만 가능하다.

## 최장 공통 문자열(Longest Common Substring)

최장 공통 부분수열(Longest Common Subsequence)을 구하기 전에 최장 공통 문자열을 먼저 보도록 하자. 해당 과정이 더 쉽고, 최장 공통 부분 수열을 구하는데 사용되기 때문이다.

### 점화식

```tsx
if (string_A[i] === string_B[j]) LCS[i][j] = LCS[i - 1][j - 1] + 1;
```

최장 공통 문자열의 점화식을 위처럼 작성할 수 있다. LCS라는 2차원 배열을 이용하여 두 문자열을 행, 열에 매칭한다. LCS 배열은 편의상 0으로 채워준다. 이후 i, j가 1이상일 때부터 검사를 시작한다. 검사 순서는 다음과 같다.

1. 문자열 A, 문자열 B의 한글자씩 비교해본다.
2. 두 문자가 **같다면** `LCS[i - 1][j - 1]` 값을 찾아 `+1` 한다.
3. 위 과정을 반복한다.

위 과정이 성립하는 이유는 공통 문자열은 연속되어야 하기 때문이다. 현재 두 문자가 같을 때, 두 문자의 앞글자까지가 공통 문자열이라면 계속 공통 문자열이 이어질 것이고, 아니라면 해당 문자부터 다시 공통 문자열을 만들어 가게 될 것이다.

<details><summary><b>구현 과정 보기</b></summary><div markdown="LCS_1">
<br />

1. **앞 마진이 0인 2차원 배열을 생성, ABCDEF 문자열과 GBCDFE 문자열을 한 글자 씩 비교**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   |     |     |     |     |     |     |
   | 2   | B   | 0   |     |     |     |     |     |     |
   | 3   | C   | 0   |     |     |     |     |     |     |
   | 4   | D   | 0   |     |     |     |     |     |     |
   | 5   | F   | 0   |     |     |     |     |     |     |
   | 6   | E   | 0   |     |     |     |     |     |     |

2. **G를 ABCDEF와 한 글자 씩 비교, 같은 문자가 없기 때문에 LCS[i][j] 값은 모두 `0`으로 채워 짐**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   |     |     |     |     |     |     |
   | 3   | C   | 0   |     |     |     |     |     |     |
   | 4   | D   | 0   |     |     |     |     |     |     |
   | 5   | F   | 0   |     |     |     |     |     |     |
   | 6   | E   | 0   |     |     |     |     |     |     |

3. **다음 B를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1     | 2     | 3   | 4   | 5   | 6   |
   | --- | --- | --- | ----- | ----- | --- | --- | --- | --- |
   | j   | -   | -   | A     | B     | C   | D   | E   | F   |
   | 0   | -   | 0   | 0     | 0     | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | **0** | 0     | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0     | **1** | 0   | 0   | 0   | 0   |
   | 3   | C   | 0   |       |       |     |     |     |     |
   | 4   | D   | 0   |       |       |     |     |     |     |
   | 5   | F   | 0   |       |       |     |     |     |     |
   | 6   | E   | 0   |       |       |     |     |     |     |

   - LCS[1][1] = 0, LCS[2][2] = 0 + 1 = 1
     <br />

4. **다음 C를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1   | 2     | 3     | 4   | 5   | 6   |
   | --- | --- | --- | --- | ----- | ----- | --- | --- | --- |
   | j   | -   | -   | A   | B     | C     | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | **1** | 0     | 0   | 0   | 0   |
   | 3   | C   | 0   | 0   | 0     | **2** | 0   | 0   | 0   |
   | 4   | D   | 0   |     |       |       |     |     |     |
   | 5   | F   | 0   |     |       |       |     |     |     |
   | 6   | E   | 0   |     |       |       |     |     |     |

   - LCS[2][2] = 1, LCS[3][3] = 1 + 1 = 2
     <br />

5. **다음 D를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1   | 2   | 3     | 4     | 5   | 6   |
   | --- | --- | --- | --- | --- | ----- | ----- | --- | --- |
   | j   | -   | -   | A   | B   | C     | D     | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0     | 0     | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0     | 0     | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 0     | 0     | 0   | 0   |
   | 3   | C   | 0   | 0   | 0   | **2** | 0     | 0   | 0   |
   | 4   | D   | 0   | 0   | 0   | 0     | **3** | 0   | 0   |
   | 5   | F   | 0   |     |     |       |       |     |     |
   | 6   | E   | 0   |     |     |       |       |     |     |

   - LCS[3][3] = 2, LCS[4][4] = 2 + 1 = 3
     <br />

6. **다음 F를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5     | 6     |
   | --- | --- | --- | --- | --- | --- | --- | ----- | ----- |
   | j   | -   | -   | A   | B   | C   | D   | E     | F     |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0     | 0     |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0     | 0     |
   | 2   | B   | 0   | 0   | 1   | 0   | 0   | 0     | 0     |
   | 3   | C   | 0   | 0   | 0   | 2   | 0   | 0     | 0     |
   | 4   | D   | 0   | 0   | 0   | 0   | 3   | **0** | 0     |
   | 5   | F   | 0   | 0   | 0   | 0   | 0   | 0     | **1** |
   | 6   | E   | 0   |     |     |     |     |       |       |

   - LCS[5][4] = 0, LCS[6][5] = 0 + 1 = 1
     <br />

7. **다음 E를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1   | 2   | 3   | 4     | 5     | 6   |
   | --- | --- | --- | --- | --- | --- | ----- | ----- | --- |
   | j   | -   | -   | A   | B   | C   | D     | E     | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0     | 0     | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0     | 0     | 0   |
   | 2   | B   | 0   | 0   | 1   | 0   | 0     | 0     | 0   |
   | 3   | C   | 0   | 0   | 0   | 2   | 0     | 0     | 0   |
   | 4   | D   | 0   | 0   | 0   | 0   | 3     | 0     | 0   |
   | 5   | F   | 0   | 0   | 0   | 0   | **0** | 0     | 1   |
   | 6   | E   | 0   | 0   | 0   | 0   | 0     | **1** | 0   |

   - LCS[4][5] = 0, LCS[5][6] = 0 + 1 = 1
     <br />

8. **최댓값을 찾으면 Longest Common Substring 탐색 종료**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 0   | 0   | 0   | 0   |
   | 3   | C   | 0   | 0   | 0   | 2   | 0   | 0   | 0   |
   | 4   | D   | 0   | 0   | 0   | 0   | 3   | 0   | 0   |
   | 5   | F   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |
   | 6   | E   | 0   | 0   | 0   | 0   | 0   | 1   | 0   |

</div></details>
<br />

## 최장 공통 부분 수열(Longest Common Subsequence)

이번에는 최장 공통 부분 수열을 만들어보자.

### 점화식

```tsx
if (string_A[i] === string_B[j]) LCS[i][j] = LCS[i - 1][j - 1] + 1;
else LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
```

최장 공통 부분 수열의 점화식을 작성해봤다. 위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사한다.

1. 문자열 A, 문자열 B의 한글자씩 비교한다.
2. 두 문자가 **같다면** `LCS[i - 1][j - 1]` 값을 찾아 `+1` 한다.
3. 두 문자가 **다르다면** `LCS[i - 1][j]`와 `LCS[i][j - 1]` 중에 큰 값을 표시한다.
4. 위 과정을 반복한다.

최장 공통 문자열을 구하는 과정과 다른 부분은 비교하는 두 문자가 다른 때이다. 비교하는 두 문자가 같을 때는 같은 과정을 보인다. **왜 어떤 부분은 다른 로직을, 어떤 부분은 같은 로직을 사용할까?**

### 1. LCS[i - 1][j]와 LCS[i][j - 1]는 어떤 의미인가?

**부분수열은 연속된 값이 아니다**. 때문에 현재의 문자를 비교하는 과정 이전의 최대 공통 부분수열은 **계속 유지된다**. ‘현재의 문자를 비교하는 과정' 이전의 과정이 바로 `LCS[i - 1][j]`와 `LCS[i][j - 1]`가 된다.

| -   | i   | 0   | 1   | 2     | 3     | 4   | 5   | 6   |
| --- | --- | --- | --- | ----- | ----- | --- | --- | --- |
| j   | -   | -   | A   | B     | C     | D   | E   | F   |
| 0   | -   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
| 1   | G   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
| 2   | B   | 0   | 0   | **1** | 0     | 0   | 0   | 0   |
| 3   | C   | 0   | 0   | `1`   | **2** | 2   | 2   | 2   |
| 4   | D   | 0   |     |       |       |     |     |     |
| 5   | F   | 0   |     |       |       |     |     |     |
| 6   | E   | 0   |     |       |       |     |     |     |

문자열 **AB**와 **GBC**를 비교(위 표의 코드로 표시된 1부분)하는 과정을 예로 들어보자. AB와 GBC의 최대 공통 부분 수열이 **B**라는 것을 알기 위해서는 **문자열 A와 GBC를 비교하는 과정, 문자열 AB와 GB를 비교하는 과정**이 필요하다. 문자열 **AB**와 **GB**의 비교 과정에서 최대 공통 부분 수열이 **B**임을 확인했기 때문에 문자열 **AB**와 **GBC**의 최대 공통 부분수열 역시 **B**가 된다.

![https://velog.velcdn.com/images%2Femplam27%2Fpost%2Ff44bccfc-9da2-4da1-80a0-c3ae9c1e9cbe%2F%EA%B3%BC%EC%A0%951.png](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Ff44bccfc-9da2-4da1-80a0-c3ae9c1e9cbe%2F%EA%B3%BC%EC%A0%951.png)

### 2. 왜 문자가 같으면 LCS[i][j] = LCS[i - 1][j - 1] + 1인가?

최대 공통 문자열을 구할 때, 비교하는 문자가 같으면 LCS[i][j] = LCS[i - 1][j - 1] + 1의 과정을 거쳤다. 이 과정이 어떻게 최대 공통 부분 수열에도 똑같이 적용될까? 부분 수열이 연속될 필요가 없음을 위 과정에서 여러번 보았다. 그렇다면 답은 간단하다. 두 문자가 같은 상황이 오면 지금까지의 최대 공통 부분 수열에 1을 더해주는 것이다.

| -   | i   | 0   | 1   | 2   | 3     | 4   | 5   | 6   |
| --- | --- | --- | --- | --- | ----- | --- | --- | --- |
| j   | -   | -   | A   | B   | C     | D   | E   | F   |
| 0   | -   | 0   | 0   | 0   | 0     | 0   | 0   | 0   |
| 1   | G   | 0   | 0   | 0   | 0     | 0   | 0   | 0   |
| 2   | B   | 0   | 0   | `1` | 0     | 0   | 0   | 0   |
| 3   | C   | 0   | 0   | `1` | **2** | 2   | 2   | 2   |
| 4   | D   | 0   |     |     |       |     |     |     |
| 5   | F   | 0   |     |     |       |     |     |     |
| 6   | E   | 0   |     |     |       |     |     |     |

문자열 **ABC**와 **GBC**를 비교(위 표에서 코드로 기입된 숫자 부분)하는 과정을 예로 들어보자. LCS 배열은 `LCS[i - 1][j]`와 `LCS[i][j - 1]`의 비교를 통해 언제나 본인까지의 최대 공통 부분수열 값을 가지고 있다. 문자열 **AB**와 **GB**를 비교할 때와 문자열 **ABC**와 **GBC**를 비교할 때 달라진 점은 두 문자열 모두에 **C**가 추가된 점이다. 때문에 기존의 최대 공통 부분 수열인 **B**에 **C**를 더한 **BC**가 최대 공통 부분 수열이 되는 것이다.

> **ABC**와 **GBC**의 최장 공통 부분 수열 = **AB**와 **GB**의 최장 공통 부분수열 + 1

<details><summary><b>구현 과정 보기</b></summary><div markdown="LCS_1">
<br />

1. **앞 마진이 0인 2차원 배열을 생성, ABCDEF 문자열과 GBCDFE 문자열을 한 글자 씩 비교**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   |     |     |     |     |     |     |
   | 2   | B   | 0   |     |     |     |     |     |     |
   | 3   | C   | 0   |     |     |     |     |     |     |
   | 4   | D   | 0   |     |     |     |     |     |     |
   | 5   | F   | 0   |     |     |     |     |     |     |
   | 6   | E   | 0   |     |     |     |     |     |     |

2. **G를 ABCDEF와 한 글자 씩 비교, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   |     |     |     |     |     |     |
   | 3   | C   | 0   |     |     |     |     |     |     |
   | 4   | D   | 0   |     |     |     |     |     |     |
   | 5   | F   | 0   |     |     |     |     |     |     |
   | 6   | E   | 0   |     |     |     |     |     |     |

3. **다음 B를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1     | 2     | 3   | 4   | 5   | 6   |
   | --- | --- | --- | ----- | ----- | --- | --- | --- | --- |
   | j   | -   | -   | A     | B     | C   | D   | E   | F   |
   | 0   | -   | 0   | 0     | 0     | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | **0** | 0     | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0     | **1** | 1   | 1   | 1   | 1   |
   | 3   | C   | 0   |       |       |     |     |     |     |
   | 4   | D   | 0   |       |       |     |     |     |     |
   | 5   | F   | 0   |       |       |     |     |     |     |
   | 6   | E   | 0   |       |       |     |     |     |     |

   - LCS[1][1] = 0, LCS[2][2] = 0 + 1 = 1
     <br />

4. **다음 C를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2     | 3     | 4   | 5   | 6   |
   | --- | --- | --- | --- | ----- | ----- | --- | --- | --- |
   | j   | -   | -   | A   | B     | C     | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | **1** | 0     | 0   | 0   | 0   |
   | 3   | C   | 0   | 0   | 1     | **2** | 2   | 2   | 2   |
   | 4   | D   | 0   |     |       |       |     |     |     |
   | 5   | F   | 0   |     |       |       |     |     |     |
   | 6   | E   | 0   |     |       |       |     |     |     |

   - LCS[2][2] = 1, LCS[3][3] = 1 + 1 = 2
     <br/ >

5. **다음 D를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2   | 3     | 4     | 5   | 6   |
   | --- | --- | --- | --- | --- | ----- | ----- | --- | --- |
   | j   | -   | -   | A   | B   | C     | D     | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0     | 0     | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0     | 0     | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 1     | 1     | 1   | 1   |
   | 3   | C   | 0   | 0   | 1   | **2** | 2     | 2   | 2   |
   | 4   | D   | 0   | 0   | 1   | 2     | **3** | 3   | 3   |
   | 5   | F   | 0   |     |     |       |       |     |     |
   | 6   | E   | 0   |     |     |       |       |     |     |

   - LCS[3][3] = 2, LCS[4][4] = 2 + 1 = 3
     <br />

6. **다음 F를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5     | 6     |
   | --- | --- | --- | --- | --- | --- | --- | ----- | ----- |
   | j   | -   | -   | A   | B   | C   | D   | E     | F     |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0     | 0     |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0     | 0     |
   | 2   | B   | 0   | 0   | 1   | 1   | 1   | 1     | 1     |
   | 3   | C   | 0   | 0   | 1   | 2   | 2   | 2     | 2     |
   | 4   | D   | 0   | 0   | 1   | 2   | 3   | **3** | 3     |
   | 5   | F   | 0   | 0   | 1   | 2   | 3   | 3     | **4** |
   | 6   | E   | 0   |     |     |     |     |       |       |

   - LCS[5][4] = 3, LCS[6][5] = 3 + 1 = 4
     <br />

7. **다음 E를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 1   | 1   | 1   | 1   |
   | 3   | C   | 0   | 0   | 1   | 2   | 2   | 2   | 2   |
   | 4   | D   | 0   | 0   | 1   | 2   | 3   | 3   | 3   |
   | 5   | F   | 0   | 0   | 1   | 2   | 3   | 3   | 4   |
   | 6   | E   | 0   | 0   | 1   | 2   | 3   | 4   | 4   |

   - LCS[4][5] = 3, LCS[5][6] = 3 + 1 = 4
     <br />

8. **최댓값을 찾으면 Longest Common Substring 탐색 종료**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 1   | 1   | 1   | 1   |
   | 3   | C   | 0   | 0   | 1   | 2   | 2   | 2   | 2   |
   | 4   | D   | 0   | 0   | 1   | 2   | 3   | 3   | 3   |
   | 5   | F   | 0   | 0   | 1   | 2   | 3   | 3   | 4   |
   | 6   | E   | 0   | 0   | 1   | 2   | 3   | 4   | 4   |

</div></details>
<br />

## 최장 공통 부분 수열(Longest Common Subsequence) 찾기

위에서 LCS 구현 과정을 통해 LCS 배열을 만들며 LCS의 길이를 알았다. 이제 만든 LCS 배열을 이용해 최장 공통 부분 수열의 값을 찾아보자. 경우에 따라 여러가지 답이 나올 수 있다.

과정은 다음과 같다.

1. LCS 배열의 **가장 마자막 값에서 시작**한다. 결과값을 저장할 `result` 배열을 준비한다.
2. `LCS[i - 1][j]`와 `LCS[i][j - 1]` 중 현재 값과 같은 값을 찾는다.
   1. 만약 **같은 값이 있다면 해당 값으로 이동**한다.
   2. 만약 **같은 값이 없다면 `result` 배열에 해당 문자를 넣고 `LCS[i - 1][j - 1]`로 이동**한다.
3. 2번 과정을 반복하다가 0으로 이동하게 되면 종료한다.
4. `result` 배열의 역순이 **LCS**이다.

```tsx
const string_A = "ABCDEF";
const string_B = "GBCDFE";

const LCS = Array.from(Array(string_A.length), () =>
  Array(string_B.length).fill(0)
);

for (let i = 1; i < string_A.length; i++) {
  for (let j = 1; j < string_B.length; j++) {
    LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
    if (string_A[i] === string_B[j]) LCS[i][j] = LCS[i - 1][j - 1] + 1;
  }
}

// LCS 결과를 담을 배열 선언
const result = [];

let r = string_A.length - 1;
let c = string_B.length - 1;

// 배열의 가장 마지막 값에서 시작하여 LCS[r - 1][c]와 LCS[r][c - 1] 중 현재 값과 같은 값 찾기
while (LCS[r][c] !== 0) {
  // 위 인덱스가 현재값과 같은 길이를 가졌다면 위로 이동
  if (LCS[r][c] === LCS[r - 1][c]) {
    r--;
    continue;
  }
  // 왼쪽 인덱스가 현재값과 같은 길이를 가졌다면 왼쪽으로 이동
  if (LCS[r][c] === LCS[r][c - 1]) {
    c--;
    continue;
  }

  // 두 조건에 해당하지 않는다면 두 문자열이 같은 값을 가진 것. result 배열에 넣어주기
  result.push(string_A[r]);
  r--;
  c--;
}

console.log(result.reverse());
```

## 참고

- [emplam27 블로그](https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-Subsequence)

<br />

[⬆ Back to Top](#lcs-알고리즘)
<br />
