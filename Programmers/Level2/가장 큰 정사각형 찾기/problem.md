# 가장 큰 정사각형 찾기

## 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/12905

## 문제 분류

: 다이나믹 프로그래밍

## 풀이 과정

처음에는 BFS나 완전 탐색으로 board를 각 부분 2차원 배열로 만들어 풀이하려고 했다. 하지만 조건을 세우기가 까다로웠고, 해당 방식들로는 문제를 풀이할 수 없었다.

이 문제는 DP를 통해서 풀이할 수 있었다.

1. board보다 행과 열이 1씩 큰 2차원 배열 dp를 생성한다.
2. 2차원 배열에서 루프를 돌면서 각 값을 확인한다.
3. 1이라면 왼쪽, 왼쪽 위, 위에 위치한 값 중에 가장 작은 값을 구한다. (0이 있다면 정사각형이 아니기 때문에)
4. 현재 위치 값에 위에서 구한 최솟값 + 1을 더해준다.
5. 4번의 값이 answer보다 큰지 비교하고, 크다면 answer에 할당한다.

board 배열에서 직접 수행할 수 있지만, 애초에 파라미터로 들어온 값을 변경하는 것이 좋지도 않고, 보드의 행과 열이 1이하일 때의 분기 처리가 따로 필요하다.

```js
if (board.length <= 1 || board[0].length <= 1) {
  return 1;
}
```

이렇게 간단하다면 할만 하겠지만, 2차원 배열이고, 위 조건에 해당하면서 모두 0일 경우를 위해 따로 분기 처리가 필요하다.

예를 들어, 아래와 같은 경우들이 있다.

```js
// 하나의 열이지만 여러 개의 행을 가졌을 경우
[[0], [0], [0], [0]][
  // 하나의 행이지만 여러 개의 열을 가졌을 경우
  [0, 0, 0, 0]
];
```

이러한 경우는 0을 반환해야 한다.그러므로 해당 경우들을 처리하기 위해 애초에 배열의 길이가 1 큰 배열을 만들어주는 것이 좋다.

## 정답 코드

```js
const solution = (board) => {
  const rows = board.length;
  const cols = board[0].length;
  const dp = Array.from(Array(rows + 1), () => Array(cols + 1).fill(0));

  let maxSide = 0;

  for (let i = 1; i <= rows; i++) {
    for (let j = 1; j <= cols; j++) {
      // 보드의 현재 위치가 1이라면
      if (board[i - 1][j - 1] === 1) {
        // dp배열에 최솟값 + 1을 해준다. (기본적으로 0으로 채워져 있기 때문에 + 1)
        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
        // 왼쪽, 왼쪽 위, 위가 모두 1이상이라면 정사각형이라는 뜻이므로 변의 최대 길이가 증가
        maxSide = Math.max(maxSide, dp[i][j]);
      }
    }
  }

  return maxSide * maxSide;
};
```
