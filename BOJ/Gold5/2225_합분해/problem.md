# 2225. 노드사이의 거리

## 문제 링크

https://www.acmicpc.net/problem/2225

## 문제 분류

: 수학, 다이나믹 프로그래밍

## 소요 시간

: 1시간 30분

## 풀이 방법

1차원 배열을 이용해 문제를 풀이하려고 하다가 시간을 많이 소비했다. 이 문제는 N과 K가 주어지는 2차원 배열로 풀 수 있는 문제였다.

문제를 풀이하기 위해 K가 2일 때부터 5정도까지 0부터 N까지의 수를 만드는 방법을 써내려가보았다. 각 방법의 수를 구한 후에 한군데에 써보니
일정한 패턴이 보였다. 수가 커질 때마다, 이전 K일 때의 값만큼 증가하고 있었다. 말로 설명하기 어려우니 표를 그려보겠다.

| K / N | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| ----- | --- | --- | --- | --- | --- | --- | --- |
| 1     | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 2     | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| 3     | 1   | 3   | 6   | 10  | 15  | 21  | 28  |
| 4     | 1   | 4   | 10  | 20  | 35  | 56  | 84  |
| 5     | 1   | 5   | 15  | 35  | 70  | 126 | 210 |

위 표를 잘 살펴보면, K일 때의 N값은 현재 N - 1값 + 현재 K - 1값으로 나타난다. 즉, 다음과 같은 점화식을 구할 수 있다.

```js
dp[K][N] = dp[K][N - 1] + dp[K - 1][N];
```

## 풀이 코드

```js
const solution = (N, K) => {
  // 0일 때는 고려하지 않고, K가 1일 경우에는 더하기를 할 수 없으므로 1로 채운다.
  const dp = Array.from(Array(K + 1), () => Array(N + 1).fill(1));
  const mod = 1_000_000_000;

  // 2부터 K까지
  for (let i = 2; i <= K; i++) {
    // N이 0일 때는 무조건 1이므로, 1부터 N까지
    for (let j = 1; j <= N; j++) {
      // 현재값은 현재 K - 1의 N일때 값 + 현재 K의 N-1값
      dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;
    }
  }

  return dp[K][n] % mod;
};
```
