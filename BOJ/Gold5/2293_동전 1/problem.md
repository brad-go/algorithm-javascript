# 2293. 노드사이의 거리

## 문제 링크

https://www.acmicpc.net/problem/2293

## 문제 분류

: 다이나믹 프로그래밍

## 소요 시간

: 2시간 이상

## 풀이 방법

한참 머리르 싸매며 문제를 풀다가 점화식을 드디어 찾아냈다. 그러나 백준 문제로 자바스크립트로는 풀 수 가 없는 문제였다.

그러나 혹시 나중에 메모리 제한이 풀릴지도 모르니 풀이를 기록해보려고한다. 이 문제를 해결하기 위해서는 각 동전까지를 사용해서 만들 수
있는 개수를 구해야 한다.

한번 문제의 예제대로 표를 그려보자면 다음과 같다.

| coin / K | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1        | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 2        | 1   | 0   | 1   | 1   | 2   | 2   | 3   | 3   | 4   | 4   | 5   |
| 5        | 1   | 0   | 0   | 0   | 0   | 1   | 1   | 2   | 2   | 3   | 4   |
| total    | 0   | 1   | 2   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 10  |

1. 1의 경우는 1만을 사용해서 K를 만들 수 있는 경우의 수
2. 2는 1의 경우를 제외한 1과 2를 사용해서 K를 만들 수 있는 경우의 수
3. 5는 1, 2의 경우를 제외하고 1, 2, 5를 사용해서 K를 만들 수 있는 경우의 수

다음과 같은 표를 구할 수 있다. 이 표를 잘 보면 모든 동전에 대해 **K - 동전 위치의 값**을 재사용한다. (K - 동전이 0보다 크거나 같을 경우)
0에다가 1을 넣어주는 이유는 각 동전 1, 2, 5에서 자신의 값만큼 뺏을 때 0이되는데, 이 때 각 동전을 사용해서 해당 수를 만들 수 있기 때문이다.

즉, 다음과 같은 점화식을 세울 수 있다.

```js
dp[i] += dp[i - coin];
```

## 풀이 코드

```js
const solution = (N, K, coins) => {
  const dp = new Array(K + 1).fill(0);

  // i - coin 시 0이 되는 것은 예를 들어 동전 가치가 2인 경우 2를 뺀 것과 같다.
  // 해당 가치를 동전 2로 만들 수 있으므로 1을 추가해야 하므로 인덱스 0을 1로 초기화한다.
  dp[0] = 1;

  // 모든 동전에 대해 한번씩 만들 수 있는 경우의 수를 탐색한다.
  coins.forEach((coin) => {
    // 현재 동전 가치 이하로는 만들 수 없으므로 해당 동전의 가치 이상부터 K까지 해당 동전과
    // 현재 동전보다 낮은 가치의 동전을 사용해서 만들 수 있는 경우의 수를 저장
    for (let i = coin; i <= K; i++) {
      dp[i] += dp[i - coin];
    }
  });

  return dp[K];
};
```
