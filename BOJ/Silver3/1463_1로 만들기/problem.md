# 1463. 1로 만들기

## 문제 링크

https://www.acmicpc.net/problem/1463

## 문제 분류

: 다이나믹 프로그래밍

## 소요 시간

: 30분

## 풀이 방법

문제를 풀이하기 위해 1 ~ 15 정도 까지의 답을 나열해봤다. 나열해보니 이전에 사용한 값을 다시 사용하는 것이 보였고, 다음과 같은 점화식을 찾을 수 있으므로 다이나믹 프로그래밍으로 문제를 풀이할 수 있다는 것을 알게 되었다.

```js
dp[i] = dp[i - 1] + 1;
dp[i] = dp[i / 3] + 1;
dp[i] = dp[i / 2] + 1;
```

문제는 주어진 세 가지 연산을 어떻게 사용하냐였다.

- X가 3으로 나누어지면, 3으로 나누기
- X가 2로 나누어지면, 2로 나누기
- 1 빼기

간단히 생각하면 가장 큰 수인 3으로 나누는 것이 가장 효율적이고, 그 다음은 2로 나누는 것이 효율적으로 보인다.

- 3이나 2로 나누어지지 않는 경우
- 3과 2의 최소 공배수인 6의 배수인 경우

3이나 2로 나누어지지 않는 경우는 1을 빼는 연산을 해줘야 한다. 중요한 것은 6의 배수인 경우는 큰 수인 3으로 나누는 것이 효율적으로 보이지만 아닌 경우도 있기 때문에 항상 비교가 필요하다.

예를 들어, 642의 경우 2로 나눈다면 10번, 3으로 나눈다면 11번의 연산이 필요하게 된다.

```
// 2로 나누기
642 -> 321 -> 320 -> 160 -> 80 -> 40 -> 20 -> 10 -> 9 -> 3 -> 1

// 3으로 나누기
642 -> 214 -> 107 -> 106 -> 53 -> 52 -> 26 -> 13 -> 12 -> 4 -> 3 -> 1
```

그러므로 다음과 같이 풀이할 수가 있다.

1. 인덱스 0은 범위를 벗어나지만, 편의상 N + 1 크기의 배열을 선언하고 0으로 채운다.
2. 1은 0번의 연산이 필요하므로 2부터 아래의 과정을 수행한다.
3. 현재 인덱스의 값을 이전 인덱스 값 더하기 1로 최신화한다.
4. 3으로 나눠진다면 현재 인덱스를 3으로 나눈값 더하기 1과 비교해 더 낮은 값으로 최신화한다.
5. 2로 나눠진다면 현재 인덱스를 2로 나눈값 더하기 1과 비교해 더 낮은 값으로 최신화한다.

각 과정을 진행하고 다음 인덱스로 넘어가는 것이 아니라 모든 과정에서 비교가 일어나야 한다. 위에서 6인 경우같은 케이스가 있으므로 항상 3으로 나누는 것이 최적해가 아닐 수 있기 때문이다.

## 풀이 코드

```js
const solution = (N) => {
  const dp = new Array(N + 1).fill(0);

  for (let i = 2; i <= N; i++) {
    dp[i] = dp[i - 1] + 1;

    if (i % 3 === 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1);
    if (i % 2 === 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1);
  }

  return dp[N];
};
```
