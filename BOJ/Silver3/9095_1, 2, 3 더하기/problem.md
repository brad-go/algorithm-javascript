# 9095. 1, 2, 3 더하기

## 문제 링크

https://www.acmicpc.net/problem/9095

## 문제 분류

: 다이나믹 프로그래밍

## 소요 시간

: 30분

## 풀이 방법

다이나믹 프로그래밍으로 풀어야 했던 것 같은데, 백트래킹을 이용해 문제를 풀이했다.
[백준 1182번 부분수열의 합](https://www.acmicpc.net/problem/1182)과 굉장히 유사한 방식으로 문제를 풀이할 수 있었다.

dfs 탐색을 통해서 현재 값이 주어진 값보다 클 때까지 1, 2, 3을 더해가면서 각각의 분기에서 탐색을 진행한다. 주어진 값 N보다 크거나 같을 때 현재 값이 주어진 값과 같다면 1, 2, 3을 이용해 N을 만든 것이므로 나타내는 방법의 수를 증가시키는 방식으로 문제를 풀이할 수 있었다.

1. 0부터 현재 값이 주어진 값(N)보다 크거나 같을 때까지 탐색을 dfs 탐색을 진행한다.
2. 각 분기마다 현재 값에 1을 더하기, 2를 더하기, 3을 더한 후에 탐색을 진행한다.
3. 현재 값이 N보다 크거나 같다면 N과 같은지 확인하고 같다면 정답을 증가시키고 탐색을 종료한다.

## 풀이 코드

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "./input.txt";
const [T, ...numbers] = fs.readFileSync(filePath).toString().trim().split("\n").map(Number); // prettier-ignore

const solution = (number) => {
  let answer = 0;

  const dfs = (current) => {
    if (current >= number) {
      answer += current === number ? 1 : 0;
      return;
    }

    dfs(current + 1);
    dfs(current + 2);
    dfs(current + 3);
  };

  dfs(0);

  return answer;
};

for (let i = 0; i < T; i++) {
  console.log(solution(numbers[i]));
}
```

## 코드 개선

원래 문제의 의도대로 dp로 풀기 위해 1, 2, 3을 각각 1, 2, 3의 더하기로 나타내보자.

| N         | 1   | 2            | 3                                      |
| --------- | --- | ------------ | -------------------------------------- |
| 방법의 수 | 1   | 1 + 1<br />2 | 1 + 1 + 1<br />1 + 2<br />2 + 1<br />3 |

1, 2, 3을 구했으니 4의 방법의 수를 구해보자.

| N         | 4                                                                                           |
| --------- | ------------------------------------------------------------------------------------------- |
| 방법의 수 | 1 + 1 + 1 + 1<br />1 + 1 + 2<br />1 + 2 + 1<br />1 + 3<br />2 + 1 + 1<br />2 + 2<br />3 + 1 |

규칙이 좀 보인다. 4는 3을 1, 2, 3의 더하기로 나타낸 방법 앞에 1을 더한 4가지 방법과, 2를 1, 2, 3의 더하기로 나타낸 방법 앞에 2를 더한 2가지 방법과 1을 1, 2, 3의 더하기로 나타낸 방법 앞에 3을 더한 1가지 방법으로 이루어져있다.

아직 감이 안온다면 5도 직접해보자. 5도 해보면 4의 방법 앞에 1을 더한 7가지, 3의 방법 앞에 2를 더한 4가지, 2의 방법 앞에 3을 더한 2가지로 이루어져 총 13가지의 방법으로 나타낼 수 있다.

이로써 하나의 점화식을 도출해낼 수 있다.

```js
dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
```

즉, 다음과 같이 풀이할 수 있다.

```js
const solution = (number) => {
  const dp = new Array(number + 1).fill(0);

  dp[1] = 1;
  dp[2] = 2;
  dp[3] = 4;

  for (let i = 4; i <= number; i++) {
    dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
  }

  return dp[number];
};
```
