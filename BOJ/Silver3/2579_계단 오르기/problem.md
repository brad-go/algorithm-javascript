# 2579. 계단 오르기

## 문제 링크

https://www.acmicpc.net/problem/2579

## 문제 분류

: 다이나믹 프로그래밍

## 소요 시간

: 30분

## 풀이 방법

계단을 오르는 규칙에서 문제 풀이의 힌트를 얻을 수 있었다.

1. 계단을 한 칸 오르거나, 두 칸 오르기
2. 연속된 세 개의 계단을 밟을 수 없다.
3. 마지막 계단은 항상 밟아야 한다.

이 규칙들을 통해서 주어진 예제의 계단을 각 칸마다 최고의 점수로 오르는 방법을 나열해보자.

| 계단    | 1   | 2    | 3    | 4       | 5          | 6          |
| ------- | --- | ---- | ---- | ------- | ---------- | ---------- |
| 점수    | 10  | 20   | 15   | 25      | 10         | 20         |
| 총점    | 10  | 30   | 35   | 55      | 65         | 75         |
| 밟은 칸 | 1   | 1, 2 | 2, 3 | 1, 2, 4 | 1, 2, 4, 5 | 1, 2, 4, 6 |

4번째 칸을 오르는 경우부터 보자. 4번째 칸을 오르기 위해서는 (1, 2, 4), (1, 3, 4), (2, 4)의 방법으로 오를 수 있다. 이 중에서 (2, 4)는 (1, 2, 4)에 속하게 되므로 4번째 칸을 오르는 방법은 (1, 2, 4)와 (1, 3, 4)이다. 각각의 점수는 55점과 50점으로 (1, 2, 4)가 해당 칸을 오르는 최적의 방법이다.

위에서 밟은 칸을 점수로 바꿔보자. (인덱스는 편의상 0을 제외하고 표시하겠음)

```js
(1, 2, 4) = scores[4] + scores[2] + scores[1]
(1, 3, 4) = scores[4] + scores[3] + scores[1]
```

위와 같이 된다. 이를 dp 배열을 통해 이전 값을 재사용해보자.

- scores[2] + scores[1]은 첫째칸과 둘째칸을 밟은 점수를 더한 dp[2]가 될 수 있다.
- scores[1]은 dp[1]과 같다.

그리고 4가 아닌 i번째라고 생각하고 식을 바꿔보자.

```js
dp[i] = scores[i] + dp[i - 2];
dp[i] = scores[i] + scores[i - 1] + dp[i - 3];
```

위와 같은 점화식을 도출해낼 수 있다. 이 식을 이용해 항상 최고의 점수를 얻어야 하므로 더 큰 값을 해당 칸의 최고 점수로 값을 넣어주면 된다.

1. 각 칸마다 최고 점수를 저장할 dp배열 선언
2. 3번째 칸까지 최고 점수를 구해서 최신화
3. 4번째 칸부터 끝까지 위의 점화식을 이용해 문제 풀이

## 풀이 코드

```js
const solution = (N, scores) => {
  const dp = new Array(N).fill(0);

  dp[0] = scores[0];
  dp[1] = scores[0] + scores[1];
  // 첫번째 세번째 칸을 밟거나, 두번째 세번째 칸을 밟거나
  dp[2] = Math.max(scores[0] + scores[2], scores[1] + scores[2]);

  for (let i = 3; i < N; i++) {
    // 위의 점화식을 이용해서 연속된 칸을 밟을 수 없으므로
    // 현재 칸과 두 칸 전까지의 값을 더한 값
    // 현재 칸과 이전 칸 세칸 전까지의 값을 더한 값
    // 을 비교해서 더 큰 값을 넣어주기
    dp[i] = scores[i] + Math.max(dp[i - 2], scores[i - 1] + dp[i - 3]);
  }

  return dp[N - 1];
};
```
