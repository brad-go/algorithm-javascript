# 11057. 오르막 수

## 문제 링크

https://www.acmicpc.net/problem/11057

## 문제 분류

: 다이나믹 프로그래밍

## 소요 시간

: 1시간

## 풀이 방법

규칙은 쉽게 발견해냈지만 이를 점화식으로 어떻게 옮겨야할지 감이 잘 안와서 한참 헤맸다. 나열해보면 쉽게 규칙을 찾을 수 있다.

| N / 오르막 수 의 개수 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --------------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1                     | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 2                     | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   |
| 3                     | 55  | 45  | 36  | 28  | 21  | 15  | 10  | 4   | 3   | 1   |
| 4                     | 220 | 165 | 120 | 84  | 56  | 35  | 20  | 10  | 4   | 1   |

2일 때부터 보면 0을 맨 앞에 두면 오르막수는 00, 01, 02, ..., 09까지 10개를 만들 수 있다. 1이 앞일 대는 그보다 하나 적은 11, 12, ..., 19까지 9개를 만들 수 있다.
9를 맨 앞에 두면 99하나를 만들 수 있으므로 N이 2일 때 총 55개를 만들 수 있다.

3일 때를 보자. 0을 앞에 두면 000, 001, 002, ..., 099까지 N이 2였을 때만큼인 55개의 오르막 수를 만들 수 있다. 1을 앞에 두면 111, 112, ..., 199까지 총 45개, 2를 앞에 두면 36개,
3을 앞에 두면 28개, ... 9가 앞일 때는 999로 1개를 만들 수 있으므로 N이 3일 때는 총 220개를 만들 수 있다.

규칙이 보인다. N이 주어졌을 때 0으로 시작하는 N자리의 오르막 수는 N - 1이 주어졌을 때의 모든 오르막 수의 합과 같다. N이 주어졌을 때 1로 시작하는 N자리의 오르막수는 N - 1이 주어졌을 때 1로 시작하는 것부터 9까지 만들 수 있는 모든 오르막 수의 합과 같다. 즉, 다음과 같은 점화식을 도출할 수 있다.

```js
dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ...dp[i - 1][9]);
```

## 풀이 코드

```js
const solution = (N) => {
  const dp = Array.from(Array(N + 1), () => Array(10).fill(1));
  const mod = 10007;

  for (let i = 2; i <= N; i++) {
    // 0 ~ 9까지
    for (let j = 0; j < 10; j++) {
      let sum = 0;

      // N - 1의 현재 인덱스 이후의 모든 값을 더한 값
      for (let k = j; k < 10; k++) {
        sum += dp[i - 1][k] % mod;
      }

      dp[i][j] = sum;
    }
  }

  return dp[N].reduce((acc, cur) => acc + cur, 0) % mod;
};
```

## 코드 개선

위의 코드는 반복문이 세 번이나 중첩되기 때문에 효율적이지 못하다. 9로 만들 수 있는 오르막 수는 항상 1이다. 그러므로 현재 구하려고하는
차례의 9번째를 1로 먼저 채운다. 그리고 N - 1의 현재 인덱스와 현재 인덱스 + 1의 값을 더해서 합을 만들어간다. 그러면 0으로 만들 수 있는 수는
이전 N - 1로 만들 수 있는 모든 오르막수의 합과 같다. 9로 만들 수 있는 오르막수를 항상 1이라고 지정하면 다음과 같은 점화식을 구할 수 있다.

```js
dp[i][j] = dp[i - 1][j] + dp[i][j + 1];
```

즉, 다음과 같이 풀이할 수 있다.

```js
const solution = (N) => {
  const dp = Array.from(Array(N + 1), () => Array(10).fill(1));

  for (let i = 2; i <= N; i++) {
    // 9로 만들 수 있는 N자리의 오르막 수는 항상 1가지이다.
    dp[i][9] = 1;

    // 8로 만들 수 있는 것부터 0으로 만들 수 있는 N자리의 오르막 수 까지 하나 씩 줄여가면서 값을 구한다.
    for (let j = 8; j >= 0; j--) {
      // 현재 수지만 한 자리 적게 만들 수 있는 오르막 수의 개수 + 현재 수보다 1 큰 수로 만들 수 있는 오르막 수의 개수
      dp[i][j] = (dp[i - 1][j] + dp[i][j + 1]) % 10007;
    }
  }

  return dp[N].reduce((acc, cur) => acc + cur, 0) % 10007;
};
```
