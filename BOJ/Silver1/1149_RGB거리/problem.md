# 1149. RGB거리

## 문제 링크

https://www.acmicpc.net/problem/1149

## 문제 분류

: 문자열

## 소요 시간

: 40분

## 풀이 방법

처음에는 백트래킹을 이용해서 문제를 풀이했는데, 시간 초과가 났다. 최대 3^1000까지의 탐색을 진행하게 되므로 그럴 수 있다.

그렇다면 dp로 풀어보자. 어떻게 dp로 풀 수 있을까 고민을 하다가 직접 써내려가면서 탐색해보기로 했다. 탐색을 하다보니
dp로 풀이할 수 있을 것 같았다. 나는 항상 이전 값에서 선택하지 않은 색 둘 중에 더 작은 값을 선택해서 더하고 있었기 때문이다.
이를 점화식으로 옮겨보자.

```
dp[i][0] = min(dp[i - 1][1], dp[i - 1][2])
dp[i][1] = min(dp[i - 1][0], dp[i - 1][2])
dp[i][2] = min(dp[i - 1][0], dp[i - 1][1])
```

이 점화식을 통해 입력받은 비용들을 탐색하면서 값을 최신화해주면서 마지막 집까지 칠하고 마지막 집까지 칠한 비용 중 가장 싼 값을 출력하면 된다.

1. 두번째 집부터 마지막 집까지 차례로 비용을 선택한다.
2. 이전 집과 색이 달라야 하므로 각 색깔을 골랐을 때, 이전 집에서 선택하지 않은 색 둘 중 싼 값을 더해준다.
3. 이 과정을 마지막까지 반복한다.
4. 마지막 집을 칠했을 때, 가장 싼 비용을 출력한다.

## 풀이 코드

```js
const solution = (N, costs) => {
  for (let i = 1; i < N; i++) {
    costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);
    costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);
    costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);
  }

  return Math.min(...dp[N - 1]);
};
```
