# 11052. 카드 구매하기

## 문제 링크

https://www.acmicpc.net/problem/11052

## 문제 분류

: 다이나믹 프로그래밍

## 소요 시간

: 1시간 30분

## 풀이 방법

다이나믹 프로그래밍을 사용해야하는 것을 거의 확실한데, 규칙을 찾아내기 꽤나 어려웠다.

문제는 1부터 N까지 dp 배열을 해당 개수의 카드를 구매할 최대 비용을 구하는 것으로 풀이할 수 있다. 그러나 카드 구매 개수가 늘어날수록 고려해야 할 구매 방법의 수가 많아져서 규칙을 찾기 어렵다. 우선 예제에서 카드를 구매하는 방법을 표로 한번 나타내보겠다.

| N         | 1   | 2           | 3                                  | 4                                                                         |
| --------- | --- | ----------- | ---------------------------------- | ------------------------------------------------------------------------- |
| 구매 방법 | 1   | 1, 1<br />2 | 1, 1, 1<br />1, 2<br />2, 1<br />3 | 1, 1, 1, 1<br />1, 1, 2<br />1 ,3<br />2, 1, 1<br />2, 2<br />3, 1<br />4 |

- N = 1 -> 한 가지 선택 방법
  - 카드 1개를 선택할 수 있으니 P1을 선택하는 방법 밖에 없다.
- N = 2 -> 두 가지 선택 방법
  - P1을 선택하고 남은 카드 개수(1)만큼 이전에 선택했던 최대 비용인 N이 1이었을 때를 더하는 방법
  - P2를 선택하는 방법
- N = 3 -> 세 가지 선택 방법
  - P1을 선택하고 남은 카드 개수(2)만큼 이전에 선택했던 최대 비용인 N이 2였을 때를 더하는 방법
  - P2를 선택하고 남은 카드 개수(1)만큼 이전에 선택했던 최대 비용인 N이 1이었을 때를 더하는 방법
  - P3을 선택하는 방법
- N = 4 -> 네 가지 선택 방법
  - P1을 선택하고 남은 카드 개수(3)만큼 이전에 선택했던 최대 비용인 N이 3이었을 때를 더하는 방법
  - P2를 선택하고 남은 카드 개수(2)만큼 이전에 선택했던 최대 비용인 N이 2였을 때를 더하는 방법
  - P3을 선택하고 남은 카드 개수(1)만큼 이전에 선택했던 최대 비용인 N이 1이었을 때를 더하는 방법
  - P4를 선택하는 방법

이전에 규칙이 보인다. 해당 카드 개수까지 카드팩을 한번씩 선택하고, 나머지 개수만큼 해당 개수를 사기 위해 필요했던 최대 비용을 더한 것을 모두 비교해서 가장 큰 값을 구하면 된다.

즉, 다음의 점화식을 구할 수 있다.

```js
// 편의상 j를 1부터 세기때문에 j - 1을 해준다.
dp[i] = max(dp[i], card[j - 1] + dp[i - j]);
```

## 풀이 코드

```js
const solution = (N, cards) => {
  // 각 카드의 개수를 구매하기 위한 최대 비용을 담을 배열
  const dp = new Array(N + 1).fill(0);

  // 카드 1개부터 N개까지
  for (let i = 1; i <= N; i++) {
    // 카드팩을 선택한다. 1부터 카드 개수까지
    for (let j = 1; j <= i; j++) {
      // 하나씩 카드팩을 선택하면서 남은 카드 개수만큼을 사기위해
      // 필요했던 최대 비용을 더한 것을 비교한다.
      // 예를 들어 i가 3이면
      // dp[3] = Math.max(dp[3], cards[0] + dp[2]) -> 카드팩 1과 2까지 최대 비용
      // dp[3] = Math.max(dp[3], cards[1] + dp[1]) -> 카드팩 2와 1까지 최대 비용
      // dp[3] = Math.max(dp[3], cards[2] + dp[0]) -> 카드팩 3과 0
      dp[i] = Math.max(dp[i], cards[j - 1] + dp[i - j]);
    }
  }

  return dp[N];
};
```
