# 1309. 동물원

## 문제 링크

https://www.acmicpc.net/problem/1309

## 문제 분류

: 다이나믹 프로그래밍

## 소요 시간

: 20분

## 풀이 방법

직접 사자를 배치하는 방법을 N이 3일 때까지 그려보았다. N이 1일 때 사자를 배치하는 방법은 세 가지이다.

- 배치하지 않기 (0, 0)
- 오른쪽 우리에 배치 (0, 1)
- 왼쪽 우리에 배치 (1, 0)

나는 이것을 이용해서 문제를 풀이했다. N이 2일 때도 생각해보자. 위, 아래 두줄이 있을 때, 윗줄에 배치하지 않는
경우는 3가지, 윗줄 왼쪽 우리에 배치하는 경우는 두가지, 윗줄 오른쪽 우리에 배치하는 경우는 두가지이다.

N이 3일 경우는 (0, 0)인 경우가 7개, (0, 1)인 경우가 5개, (1, 0)인 경우가 5개이다. 우리는 일정한 패턴을 찾을 수 있다.

| 배치 / N           | 0   | 1   | 2   | 3   | 4   | 5   |
| ------------------ | --- | --- | --- | --- | --- | --- |
| 배치 하지 않음 (0) | 0   | 1   | 3   | 7   | 17  | 41  |
| 왼쪽 (1)           | 0   | 1   | 2   | 5   | 12  | 29  |
| 오른쪽 (2)         | 0   | 1   | 2   | 5   | 12  | 29  |
| 총합               | 0   | 3   | 7   | 17  | 41  | 99  |

배치하지 않음을 0, 왼쪽을 1, 오른쪽을 2로 가정했을때, 이를 통해 점화식을 만들 수 있다.

```js
dp[i][0] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2];
dp[i][1] = dp[i - 1][0] + dp[i - 1][1];
dp[i][2] = dp[i - 1][0] + dp[i - 1][1];
```

## 풀이 코드

```js
const solution = (N) => {
  const dp = Array.from(Array(N + 1), () => Array(3).fill(1));
  const mod = 9901;

  for (let i = 2; i <= N; i++) {
    dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % mod;
    dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) % mod;
    dp[i][2] = dp[i][1];
  }

  return dp[N].reduce((acc, cur) => acc + cur, 0) % mod;
};
```

## 코드 개선

얼른 푸느라 제대로 점화식을 도출하지 못한 것 같다. 위 표를 다시보면 새로운 점화식을 도출할 수 있다.

```js
dp[i] = dp[i - 1] * 2 + dp[i - 2];
```

즉, 다음과 같이 풀이할 수 있다.

```js
const solution = (N) => {
  const dp = new Array(N + 1).fill(0);

  dp[1] = 3;
  dp[2] = 7;

  for (let i = 3; i <= N; i++) {
    dp[i] = (dp[i - 1] * 2 + dp[i - 2]) % 9901;
  }

  return dp[N];
};
```
