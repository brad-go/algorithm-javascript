# 쉬운 계단 수 - 10844

[문제 링크](https://www.acmicpc.net/problem/10844)

### 성능 요약

메모리: 256MB, 시간 1초

### 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

### 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

### 예제 입력 1

```
1
```

### 예제 출력 1

```
9
```

### 예제 입력 2

```
2
```

### 예제 출력 2

```
17
```

<details><summary><b>문제 풀이</b></summary>
<div markdown="1">

### Fail

```js
const input = Number(
  require("fs").readFileSync("./input2.txt").toString().trim()
);

function Solution(n) {
  const BILLION = 1000000000;
  const dp = new Array(n + 1).fill(0);
  dp[1] = 9;

  for (let i = 2; i < n + 1; i++) {
    dp[i] = dp[i - 1] * 2 - (i - 1);
  }

  console.log(dp[n] % BILLION);
}

Solution(input);
```

n이 4일 때까지 구해보니 `이전 해 * 2 - i`라는 규칙이 보여서 이를 토대로 문제를 풀려고 했다.
문제 제목도 쉬운 계단 수여서 쉽게 풀 수 있는거구나~ 하고 했는데, 아무리 해도 틀렸다고 나왔다.

### Solution

처음에는 최적의 해의 값들만을 가지고 문제를 풀려고 했는데, N이 4일 때까지는 규칙이 적용되지만, 5부터는 적용되지 않았다. 이 문제는 **이차원 배열**을 이용해서 풀어야 하는 문제였다.

#### 규칙 찾기

규칙을 찾을때, 0 - 9까지 시작하는 수로 해서 써내려가보면서 규칙을 찾으려고 했는데, 핵심은 **해당 수로 끝나는 수로 묶어서 보는 것**이었다.

| N   | 0   | 1             | 2             | 3                  | 4                  | 5                  | 6                  | 7                  | 8             | 9        |
| --- | --- | ------------- | ------------- | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ | ------------- | -------- |
| 1   | x   | 1             | 2             | 3                  | 4                  | 5                  | 6                  | 7                  | 8             | 9        |
| 2   | 10  | 21            | 12, 32        | 23, 43             | 34, 54             | 45, 65             | 56, 76             | 67, 87             | 78, 98        | 89       |
| 3   | 210 | 101, 121, 321 | 212, 232, 432 | 123, 323, 343, 543 | 234, 434, 454, 654 | 345, 545, 565, 765 | 456, 656, 676, 876 | 567, 767, 787, 987 | 678, 878, 898 | 789, 989 |

N이 3일 때까지만 보자면 위와 같이 수들을 구할 수 있다. 그렇다면 각 개수들을 살펴보자.

| N   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 2   | 1   | 1   | 2   | 2   | 2   | 2   | 2   | 2   | 2   | 1   |
| 3   | 1   | 3   | 3   | 4   | 4   | 4   | 4   | 4   | 3   | 2   |

규칙이 조금 보이는가? 각 해당 위치의 좌우 대각선 위 수들의 합이라는 규칙을 찾을 수 있다. 그러므로 위 표를 통해서 다음과 같은 점화식을 구할 수 있다.

```js
dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % 1000000000;
```

하지만 이 점화식만으로는 풀 수 없다. 0과 9에서 값을 구할 수 없기 때문이다. 0은 왼쪽 대각선 위가 없고, 9는 오른쪽 대각선 위가 없다. 그러므로 다음과 같이 0은 오른쪽 대각선만, 9는 왼쪽 대각선만 더한 값을 저장해준다.

```js
dp[i][0] = dp[i - 1][1];
dp[i][9] = dp[i - 1][8];

for (let j = 1; j < 9; j++) {
  dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % BILLION;
}

// 혹은

for (let j = 0; j <= 9; j++) {
  dp[i][j] = (dp[i - 1][j - 1] || 0) + ((dp[i - 1][j + 1] || 0) % BILLION);
}
```

0과 9일 경우를 따로 값을 넣어주고 반복문을 돌리거나, 한번에 반복문을 돌리면서 인덱스가 존재하지 않을 경우 0을 넣어주는 방식으로 해결할 수 있다.

#### Answer

```js
const input = Number(require("fs").readFileSync("dev/stdin").toString().trim());

function Solution(n) {
  const BILLION = 1000000000;
  const MAX_NATURAL_NUM = 9;

  const dp = Array.from(Array(n), () => [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  dp[0] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1];

  for (let i = 1; i < n; i++) {
    for (let j = 0; j <= MAX_NATURAL_NUM; j++) {
      dp[i][j] = (dp[i - 1][j - 1] || 0) + ((dp[i - 1][j + 1] || 0) % BILLION);
    }
  }

  const answer = dp[n - 1].reduce((acc, cur) => (acc + cur) % BILLION, 0);
  console.log(answer % BILLION);
}

Solution(input);
```

</div>
</details>
