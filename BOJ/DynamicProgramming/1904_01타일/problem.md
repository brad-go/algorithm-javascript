# 01타일 - 1904번

[문제 링크](https://www.acmicpc.net/problem/1904)

### 성능 요약

메모리: 256MB, 시간 0.75초

### 문제

지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.

어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.

그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.

우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.

### 입력

첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)

### 출력

첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.

### 제한

-50 <= a, b, c <= 50

### 예제 입력

```
4
```

### 예제 출력

```
5
```

<details><summary><b>문제 풀이</b></summary>
<div markdown="1">

어떻게 접근해야 할지 생각하기 위해 손으로 N의 개수만큼 가질 수 있는 만들 수 있는 타일의 개수를
써내려갔다. 그런데 딱 피보나치 수열이 떠올랐다. N이 증가할 때마다 이전 N의 개수만큼 증가했기 때문이다.

세운 점화식은 다음과 같다.

```js
dp[i] = dp[i - 1] + dp[i - 2];
```

그러나 문제는 해결되지 않았다. 저렇게 식을 세운 후 2까지의 최적의 해를 구해서 대입해주었다. 그리고 구한 해를 15746으로 나누어주었다.

```js
console.log(dp[n] % 15746);
```

그리고 실행해보면 답이 잘 나왔는데, 왜 문제가 풀리지 않았나 생각해봤더니 당연한 거였다. 각 최적의 해를 구한 배열이어야 하는데, 수가 커지면 15746으로 나누는 과정이 점화식 안으로 들어가야 했다. 그래서 구한 해답은 다음과 같다.

### Solution

```js
const input = Number(
  require("fs").readFileSync("./input.txt").toString().trim()
);

function Solution(n) {
  const dp = new Array(n + 1).fill(-1);
  dp[0] = 0;
  dp[1] = 1;
  dp[2] = 2;

  for (let i = 0; i < dp.length; i++) {
    if (dp[i] === -1) {
      dp[i] = (dp[i - 1] + dp[i - 2]) % 15746;
    }
  }

  console.log(dp[n]);
}

Solution(input);
```

</div>
</details>
