# 전깃줄 - 2565번

[문제 링크](https://www.acmicpc.net/problem/2565)

### 성능 요약

메모리: 256MB, 시간 1초

### 문제

두 전봇대 A와 B 사이에 하나 둘씩 전깃줄을 추가하다 보니 전깃줄이 서로 교차하는 경우가 발생하였다. 합선의 위험이 있어 이들 중 몇 개의 전깃줄을 없애 전깃줄이 교차하지 않도록 만들려고 한다.

예를 들어, < 그림 1 >과 같이 전깃줄이 연결되어 있는 경우 A의 1번 위치와 B의 8번 위치를 잇는 전깃줄, A의 3번 위치와 B의 9번 위치를 잇는 전깃줄, A의 4번 위치와 B의 1번 위치를 잇는 전깃줄을 없애면 남아있는 모든 전깃줄이 서로 교차하지 않게 된다.

<div align="center">
  <img src="https://upload.acmicpc.net/d90221dd-eb80-419f-bdfb-5dd4ebac23af/-/preview/" alt="그림 1">
  < 그림 1 >
</div>

전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때, 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다. 전깃줄의 개수는 100 이하의 자연수이다. 둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다. 위치의 번호는 500 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.

### 출력

첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.

### 예제 입력

```
8
1 8
3 9
2 2
4 1
6 4
10 10
9 7
7 6
```

### 예제 출력

```
3
```

<details><summary><b>문제 풀이</b></summary>
<div markdown="1">

조건문은 세울 수 있었지만, 정렬을 한다는 아이디어가 떠오르지 않아서 문제 풀이에 실패했다. 다른 블로그들을 살펴보며 문제 풀이에 대해 이해했다.

### 풀이

문제에서 주어진 예시를 보자. 위에서 부터 전깃줄을 연결한다고 가정하면, 각 단계에서 겹치지 않고 설치할 수 있는 최대 전깃줄은 다음과 같다.

- 0번째 전깃줄(1-8)만 사용했을 때: 1개 ([1, 8])
- 1번째 전깃줄(2-2)만 사용했을 때: 1개 ([2, 2])
- 2번째 전깃줄(3-9)만 사용했을 때: 2개 ([2, 2], [3, 9])
- 3번째 전깃줄(4-1)만 사용했을 때: 1개 ([4, 1])
- 4번째 전깃줄(6-4)만 사용했을 때: 2개 ([2, 2], [6, 4])
- 5번째 전깃줄(7-6)만 사용했을 때: 3개 ([2, 2], [6, 4], [7, 6])
- 6번째 전깃줄(9-7)만 사용했을 때: 4개 ([2, 2], [6, 4], [7, 6], [9, 7])
- 7번째 전깃줄(10-10)만 사용했을 때: 5개 ([2, 2], [6, 4], [7, 6], [9, 7], [10, 10])

마지막 전깃줄까지 사용했을 때, 설치할 수 있는 최대 전깃줄은 5줄([2, 2], [6, 4], [7, 6], [9, 7], [10, 10])이며 없애야 하는 전깃줄의 개수는 3개이다.

전깃줄이 겹치지 않게 하기 위해서는 양 전봇대의 번호가 증가하는 순서로 이루어져야 한다. 예를 들어, 전깃줄 [1, 8]과 전깃줄 [2, 2]는 겹치지만, 전깃줄 [1, 8]과 전깃줄 [3, 9]는 겹치지 않는다.

즉, 전깃줄을 순회하면서 이전 전깃줄의 시작 번호보다 현재 전깃줄의 시작 번호가 크고, 동시에 **이전 전깃줄의 끝 번호보다 현재 전깃줄의 끝 번호가 커야 현재 보고 있는 전깃줄을 추가로 설치**할 수 있게 된다.

### 핵심 아이디어

결과적으로 이 문제를 풀기 위한 핵심 아이디어는 다음과 같다.

- 한쪽 전봇대를 기준으로 **정렬**하기
- LIS와 같이 반복문을 통해 순회하면서 최대로 설치할 수 있는 전깃줄의 개수를 dp배열에 저장하기
- 정렬한 이후라면 현재 끝 번호가 이전 끝 번호보다 클 경우에만 전깃줄 추가 설치 가능(최장 증가 부분 수열과 같음)

전봇대 입력받고 A 전봇대(왼쪽)를 기준으로 오름차순 정렬하기

```js
const pole = input
  .map((line) => line.split(" ").map((v) => +v))
  .sort((a, b) => a[0] - b[0]);
```

dp배열 생성. 전깃줄이 하나라면 무조건 하나는 설치할 수 있으므로, 1로 채우기

```js
const dp = new Array(N).fill(1);
```

반복문을 돌면서 현재 전깃줄의 끝 번호(오른쪽 전봇대)가 이전 전깃줄의 끝 번호보다 클때마다 증가시키기. 이전 전깃줄의 시작 번호보다 현재 전깃줄의 시작 번호가 커야 하지만 반복문에 의해서 조건을 따로 추가해줄 필요가 없다. (i는 항상 j보다 크다)

그러므로 최장 증가 부분 수열을 구하는 알고리즘과 일치

```js
for (let i = 1; i < N; i++) {
  for (let j = 0; j < i; j++) {
    if (pole[j][1] < pole[i][1]) dp[i] = Math.max(dp[i], dp[j] + 1);
  }
}
```

최장 증가하는 부분 수열 부분은 전깃줄을 설치할 수 있는 개수와 같으므로, 제거해야 할 전깃줄을 구하기 위해 전체 전깃줄의 개수에서 최장 증가 부분 수열에서 가장 큰 수를 빼준다.

### 코드

```js
const [n, ...input] = require("fs")
  .readFileSync("./input.txt")
  .toString()
  .trim()
  .split("\n");

function Solution(n, input) {
  const N = Number(n);
  const pole = input
    .map((line) => line.split(" ").map((v) => +v))
    .sort((a, b) => a[0] - b[0]);

  const dp = new Array(N).fill(1);

  for (let i = 1; i < N; i++) {
    for (let j = 0; j < i; j++) {
      if (pole[j][1] < pole[i][1]) dp[i] = Math.max(dp[i], dp[j] + 1);
    }
  }

  const answer = N - Math.max(...dp);
  console.log(answer);
}

Solution(n, input);
```

</div>
</details>
