# 평범한 배낭 - 12865번

[문제 링크](https://www.acmicpc.net/problem/12865)

### 성능 요약

메모리: 256MB, 시간 1초

### 문제

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

### 입력

첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

### 출력

한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

### 예제 입력

```
4 7
6 13
4 8
3 6
5 12
```

### 예제 출력

```
14
```

<details><summary><b>문제 풀이</b></summary>
<div markdown="1">

냅색 문제를 처음 접해봤는데, 작은 문제로 쪼개는 것이 쉽지 않았다. 작은 문제로 나누기 위해 다음의 경우를 우선 생각해야 했다.

배낭의 물건을 넣을 때, 선택할 수 있는 것은 두가지다.

- 물건 넣기
- 물건 넣지 않기

현재 넣으려는 물건의 무게가 준서가 들 수 있는 무게(K)를 초과한다면, 물건을 넣지 않고 건너뛰어야 한다. 따라서 같은 점화식을 구할 수 있다.

```js
if (curWeight > w) dp[i][j] = dp[i - 1][j];
```

`dp`는 말그대로 **최대 가치를 담는 배열**이고, `i`는 **현재 넣은 물건**, `j`는 **최대 무게**를 의미한다. `curWeight`은 **현재 물건의 무게**를 의미한다. 즉, 위 식은 물건이 총 제한 무게를 초과한다면 `i`번째 최대가치를 바로 `i-1`번째 물건을 넣을 경우(이전 물건을 넣을 경우)의 가치로 정하는 것이다.

만약 물건을 넣을 수 있는 무게가 남았다면? 다시 두가지 선택을 할 수 있다.

- 새로운 물건을 넣지 않는다.
- 새로운 물건을 넣을 공간을 확인하고 넣는다.

문제에서 최대 가치를 구해야 하기 때문에, 두 경우 중 더 큰 값을 선택하게 된다.

```js
dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - curWeight] + curValue);
```

현재 물건을 넣기 위해 넣었던 물건을 뺏을 때의 가치에 현재 물건을 가치를 더해준 값을 비교한다.

### 코드

```js
const input = require("fs")
  .readFileSync("./input.txt")
  .toString()
  .trim()
  .split("\n");

function Solution(input) {
  const [N, K] = input
    .shift()
    .split(" ")
    .map((v) => +v);
  const items = input.map((item) => item.split(" ").map((v) => +v));
  items.unshift([0, 0]);

  const dp = Array.from(Array(N + 1), () => Array(K + 1).fill(0));

  for (let i = 1; i <= N; i++) {
    const curWeight = items[i][0];
    const curValue = items[i][1];

    for (let j = 1; j <= K; j++) {
      // 기본적으로 모두 이전 물건의 가치를 부여
      dp[i][j] = dp[i - 1][j];

      // 현재 물건이 가방의 총량보다 작아서 넣을 수 있다면
      if (curWeight <= j)
        // 이전 물건의 가치와 현재 물건을 넣었을 때의 가치를 비교
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - curWeight] + curValue);
    }
  }

  console.log(dp[N][K]);
}

Solution(input);
```

</div>
</details>
