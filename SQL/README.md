# SQL 문제 풀이

## 목차

- [난이도 별 분류](#난이도-별-분류)
- [유형 별 분류](#유형-별-분류)
- [SQL 문법 정리](#sql-문법-정리)

## 난이도 별 분류

### LEVEL 1

- [평균 일일 대여 요금 구하기](./Level1/평균%20일일%20대여%20요금%20구하기/problem.md)
- [인기있는 아이스크림](./Level1/인기있는%20아이스크림/problem.md)
- [과일로 만든 아이스크림 고르기](./Level1/과일로%20만든%20아이스크림%20고르기/problem.md)
- [강원도에 위치한 생산공장 목록 출력하기](./Level1/강원도에%20위치한%20생산공장%20목록%20출력하기/problem.md)
- [12세인 여자 환자 목록 출력하기](./Level1/12세인%20여자%20환자%20목록%20출력하기/problem.md)
- [상위 n개 레코드](./Level1/상위%20n개%20레코드/problem.md)
- [가장 비싼 상품 구하기](./Level1/가장%20비싼%20상품%20구하기/problem.md)

### LEVEL 2

- [3월에 태어난 여성 회원 목록 출력하기](./Level2/3월에%20태어난%20여성%20회원%20목록%20출력하기/problem.md)
- [재구매가 일어난 상품과 회원 리스트 구하기](./Level2/재구매가%20일어난%20상품과%20회원%20리스트%20구하기/problem.md) <sup>다시 풀기</sup>
- [가격이 제일 비싼 식품의 정보 출력하기](./Level2/가격이%20제일%20비싼%20식품의%20정보%20출력하기/problem.md)
- [진료과별 총 예약 횟수 출력하기](./Level2/진료과별%20총%20예약%20횟수%20출력하기/problem.md)
- [자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기](./Level2/자동차%20종류%20별%20특정%20옵션이%20포함된%20자동차%20수%20구하기/problem.md)

### LEVEL 3

- [대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기](./Level3/대여%20횟수가%20많은%20자동차들의%20월별%20대여%20횟수%20구하기/problem.md) <sup>다시 풀기</sup>
- [카테고리 별 도서 판매량 집계하기](./Level3/카테고리%20별%20도서%20판매량%20집계하기/problem.md)
- [즐겨찾기가 가장 많은 식당 정보 출력하기](./Level3/즐겨찾기가%20가장%20많은%20식당%20정보%20출력하기/problem.md)
- [자동차 대여 기록에서 대여중 대여 가능 여부 구분하기](./Level3/자동차%20대여%20기록에서%20대여중%20대여%20가능%20여부%20구분하기/problem.md) <sup>다시 풀기</sup>

### LEVEL 4

- [서울에 위치한 식당 목록 출력하기](./Level4/서울에%20위치한%20식당%20목록%20출력하기/problem.md) <sup>다시 풀기</sup>
- [오프라인 온라인 판매 데이터 통합하기](./Level4/오프라인%20온라인%20판매%20데이터%20통합하기/problem.md) <sup>다시 풀기</sup>
- [저자 별 카테고리 별 매출액 집계하기](./Level4/저자%20별%20카테고리%20별%20매출액%20집계하기/problem.md) <sup>다시 풀기</sup>
- [식품분류별 가장 비싼 식품의 정보 조회하기](./Level4/식품분류별%20가장%20비싼%20식품의%20정보%20조회하기/problem.md) <sup>다시 풀기</sup>

<br />

[⬆ Back to Top](#목차)
<br />

## 유형 별 분류

### SELECT

- [평균 일일 대여 요금 구하기](./Level1/평균%20일일%20대여%20요금%20구하기/problem.md)
- [인기있는 아이스크림](./Level1/인기있는%20아이스크림/problem.md)
- [3월에 태어난 여성 회원 목록 출력하기](./Level2/3월에%20태어난%20여성%20회원%20목록%20출력하기/problem.md)
- [과일로 만든 아이스크림 고르기](./Level1/과일로%20만든%20아이스크림%20고르기/problem.md)
- [서울에 위치한 식당 목록 출력하기](./Level4/서울에%20위치한%20식당%20목록%20출력하기/problem.md) <sup>다시 풀기</sup>
- [강원도에 위치한 생산공장 목록 출력하기](./Level1/강원도에%20위치한%20생산공장%20목록%20출력하기/problem.md)
- [재구매가 일어난 상품과 회원 리스트 구하기](./Level2/재구매가%20일어난%20상품과%20회원%20리스트%20구하기/problem.md) <sup>다시 풀기</sup>
- [12세인 여자 환자 목록 출력하기](./Level1/12세인%20여자%20환자%20목록%20출력하기/problem.md)
- [오프라인 온라인 판매 데이터 통합하기](./Level4/오프라인%20온라인%20판매%20데이터%20통합하기/problem.md) <sup>다시 풀기</sup>
- [상위 n개 레코드](./Level1/상위%20n개%20레코드/problem.md)

### SUM, MAX, MIN

- [가장 비싼 상품 구하기](./Level1/가장%20비싼%20상품%20구하기/problem.md)
- [가격이 제일 비싼 식품의 정보 출력하기](./Level2/가격이%20제일%20비싼%20식품의%20정보%20출력하기/problem.md)

### GROUB BY

- [진료과별 총 예약 횟수 출력하기](./Level2/진료과별%20총%20예약%20횟수%20출력하기/problem.md)
- [저자 별 카테고리 별 매출액 집계하기](./Level4/저자%20별%20카테고리%20별%20매출액%20집계하기/problem.md) <sup>다시 풀기</sup>
- [식품분류별 가장 비싼 식품의 정보 조회하기](./Level4/식품분류별%20가장%20비싼%20식품의%20정보%20조회하기/problem.md) <sup>다시 풀기</sup>
- [대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기](./Level3/대여%20횟수가%20많은%20자동차들의%20월별%20대여%20횟수%20구하기/problem.md) <sup>다시 풀기</sup>
- [카테고리 별 도서 판매량 집계하기](./Level3/카테고리%20별%20도서%20판매량%20집계하기/problem.md)
- [즐겨찾기가 가장 많은 식당 정보 출력하기](./Level3/즐겨찾기가%20가장%20많은%20식당%20정보%20출력하기/problem.md)
- [자동차 대여 기록에서 대여중 대여 가능 여부 구분하기](./Level3/자동차%20대여%20기록에서%20대여중%20대여%20가능%20여부%20구분하기/problem.md) <sup>다시 풀기</sup>
- [자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기](./Level2/자동차%20종류%20별%20특정%20옵션이%20포함된%20자동차%20수%20구하기/problem.md)

<br />

[⬆ Back to Top](#목차)
<br />

## SQL 문법 정리

### SQL 문법 목차

- [SQL 쿼리 실행 순서](#sql-쿼리-실행-순서)
- [데이터 읽어오기](#select-데이터-읽어오기)
- [조건문](#where-조건문)
- [정렬하기](#order-by-정렬하기)
- [문자열 자르기](#문자열-자르기-substr-substring-left-right)
- [날짜 출력하기](#날짜-출력하기)
- [두 개의 테이블에서 데이터 추출하기](#두-개의-테이블에서-데이터-추출하기-join)
- [그룹화해서 데이터 조회하기](#그룹화해서-데이터-조회하기-group-by)
- [NULL 처리하기](#null-처리하기-ifnull-case-coalesce)
- [여러 테이블의 데이터를 하나의 쿼리로 추출하기](#여러-테이블의-데이터를-하나의-쿼리로-추출하기-union-union-all)
- [상위 n개 레코드 출력하기](#상위-n개-레코드-출력하기-limit)
- [집계함수](#집계함수-count-sum-avg-min-max)
- [중복행 제거하기](#중복-행-제거하기-distinct)
- [임시 테이블 만들기](#임시-테이블-만들기-with)

### SQL 쿼리 실행 순서

```sql
FROM -> ON -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY -> LIMIT
```

- FROM : 조회 테이블 확인
- ON : 조인 조건 확인
- JOIN : 테이블 조인 (병합)
- WHERE : 데이터 추출 조건 확인
- GROUP BY : 특정 컬럼 그룹화
- HAVING : 그룹화 이후 데이터 추출 조건
- SELECT : 데이터 추출
- DISTINCT : 중복 제거
- ORDER BY : 데이터 순서 정렬
- LIMIT : 맨 위부터 n개까지의 레코드를 선택

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 데이터 읽어오기 (SELECT)

데이터를 읽어오기 위해 SELECT문을 사용합니다. CRUD 중 Read에 해당합니다.

```sql
-- 기본 구조
SELECT 필드이름
FROM 테이블

-- 여러 필드를 조회하는 경우
SELECT 필드이름1, 필드이름2
FROM 테이블

-- 모든 필드를 조회하는 경우
SELECT *
FROM 테이블

-- 중복된 데이터를 없앤 필드를 조회하는 경우
SELECT DISTINCT 필드이름
FROM 테이블
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 조건문 (WHERE)

SELECT, UPDATE, DELETE문 등에 특정 레콛에 대해 조건을 사용하기 위해서는 WHERE문을 사용합니다.

```sql
-- 단일 조건식을 적용하는 경우
SELECT 필드이름 혹은 * FROM 테이블
WHERE 필드이름 = 비교값

-- 여러 조건식을 적용하는 경우 AND나 OR을 연결해서 적용할 수 있습니다.
SELECT 필드이름 혹은 * FROM 테이블
WHERE 필드이름1 = 비교값1
AND 필드이름2 = 비교값2
OR 필드이름3 = 비교값3

-- LIKE. 해당 패턴에 해당되는 레코드들을 선별할 때 사용됩니다.
-- 일치하는 것을 찾을 경우 값을 그대로 작성해주고, 특정 문자열로 시작하는
-- 레코드를 선별한 경우 %를 뒤에 붙여 사용합니다.
SELECT 필드이름 혹은 * FROM 테이블
WHERE 필드이름 LIKE 비교값%

-- IN은 해당 컬럼이 어떤 값들의 집합에 속할 경우를 나타냅니다.
SELECT 필드이름 혹은 * FROM 테이블
WHERE 필드이름 IN (값1, 값2, 값3)

-- BETWEEN은 컬럼값이 BETWEEN...AND의 범위값에 든 경우를 나타냅니다.
SELECT 필드이름 혹은 * FROM 테이블
WHERE 필드이름 BETWEEN 값1 AND 값2

-- 컬럼값이 널(NULL)인 경우를 체크하기 위해서는 IS NULL을 사용합니다.
-- 반대의 경우 IS NOT NULL 을 사용합니다.
SELECT 필드이름 혹은 * FROM 테이블
WHERE 필드이름 IS NULL
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 정렬하기 (ORDER BY)

데이터를 정렬하기 위해서는 ORDER BY를 사용합니다.

```sql
-- 특정 필드를 기준으로 정렬할 경우
SELECT 필드이름 FROM 테이블
ORDER BY 필드이름

-- 정렬 기준이 여러개인 경우 --> 필드이름 1을 기준으로 정렬하고, 비교값이 같다면 필드이름2를 기준으로 정렬합니다.
SELECT 필드이름 FROM 테이블
ORDER BY 필드이름1, 필드이름2, 필드이름3

-- 내림차순 정렬을 위해서 DESC를 사용
SELECT 필드이름 FROM 테이블
ORDER BY 필드이름1 DESC

-- 오름차순 정렬을 위해서 ASC를 사용
SELECT 필드이름 FROM 테이블
ORDER BY 필드이름1 ASC
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 문자열 자르기 (SUBSTR, SUBSTRING, LEFT, RIGHT)

SQL에서 문자열을 자르기 위해 SUBSTR, SUBSTRING, LEFT, RIGHT을 사용할 수 있다.

```sql
-- 기본 데이터
SELECT "string" as email; -- email: string

-- SUBSTR. SUBSTRING. 원하는 문자열을 시작 위치부터 마지막 위치까지 자르기
-- SUBSTR[ING](원하는 문자열, 시작 위치, 길이)
-- 길이를 미 입력시 마지막까지 추출
SELECT SUBSTR("string", 1, 3) as email; -- email: str
SELECT SUBSTRING("string", 1, 3) as email; -- email: str
SELECT SUBSTR("string", 3) as email; -- email: ring

-- LEFT. 원하는 문자열을 왼쪽 첫 번째부터 입력받은 길이만큼 추출하기
SELECT LEFT('string', 3) as email -- email: str

-- RIGHT. 원하는 문자열을 오른쪽 첫 번째부터 입력받은 길이만큼 추출하기
SELECT RIGHT('string', 4) as email -- email: ring
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 날짜 출력하기

#### DATE_FORMAT

날짜를 지정한 형식으로 출력하기 위해서 사용합니다.

```sql
-- 기본 문법
DATE_FORMAT(날짜, 형식)
```

| 구분 기호 | 역할             | 구분 기호 | 역할             |
| --------- | ---------------- | --------- | ---------------- |
| %Y        | 4자리 년도       | %d        | 숫자 일(두 자리) |
| %y        | 2자리 년도       | %e        | 숫자 일(한 자리) |
| %M        | 긴 영문 월       | %H        | 시간(24 시간)    |
| %b        | 짧은 영문 월     | %l        | 시간(12 시간)    |
| %W        | 긴 요일 이름     | %i        | 분               |
| %a        | 짧은 요일 이름   | %s        | 초               |
| %m        | 숫자 월(두 자리) | %T        | hh:mm:ss         |
| %c        | 숫자 월(한 자리) | %r        | hh:mm:ss AM, PM  |

```sql
SELECT DATE_FORMAT(NOW(),'%Y-%m-%d') AS DATE FROM DUAL -- DATE: 2023-02-09
SELECT DATE_FORMAT(NOW(),'%Y %M %D %T') AS DATE FROM DUAL -- 2023 February 9th 09:25:07
```

#### YEAR, MONTH, DAY, HOUR, MINUTE, SECOND

주어진 날짜로부터 각 단위를 추출하기 위해 사용합니다.

```sql
SELECT YEAR('2023-02-09 09:25:07') -- 2023
SELECT MONTH('2023-02-09 09:25:07') -- 2
SELECT DAY('2023-02-09 09:25:07') -- 9
SELECT HOUR('2023-02-09 09:25:07') -- 9
SELECT MINUTE('2023-02-09 09:25:07') -- 25
SELECT SECOND('2023-02-09 09:25:07') -- 7
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 두 개의 테이블에서 데이터 추출하기 (JOIN)

![내부 조인](https://hongong.hanbit.co.kr/wp-content/uploads/2021/11/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-SQL_INNER-JOIN.png)
[출처: 혼공러들의 스터디 공간]

두 개의 테이블을 엮어야 결과를 얻을 수 있을 때는 JOIN을 사용합니다. 두 테이블의 조인을 위해서는
**기본키와 외래키 관계**로 이루어져 있어야 하며, 이것을 **일대다 관계**라고 합니다.

JOIN은 두 개의 테이블을 서로 묶어서 하나의 결과를 만들어 내는 것입니다. JOIN에는 4가지 종류가 있는데, INNER JOIN, OUTER JOIN, CROSS JOIN, SELF JOIN이 있습니다.

#### INNER JOIN(내부 조인)

기본적인 JOIN을 의미하며 두 테이블을 연결할 때 가장 많이 사용하는 것이 내부 조인입니다. 두 테이블에 모두 지정한 컬럼의 데이터가 있어야 합니다. 교집합을 만드는 것과 비슷합니다.

```sql
SELECT 컬럼 목록
FROM 첫 번째 테이블
  INNER JOIN 두 번째 테이블 -- INNER JOIN을 JOIN이라고 작성해도 같은 역할을 합니다.
  ON 조인될 조건
WHERE 검색 조건
```

#### OUTER JOIN(외부 조인)

![외부 조인](https://hongong.hanbit.co.kr/wp-content/uploads/2021/11/OUTER-JOIN_%EB%8D%94%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0.png)
[출처: 혼공러들의 스터디 공간]

INNER JOIN과 달리 두 테이블에 모두 데이터가 있어야 결과가 나오는 것이 아니라, OUTER JOIN은 한 쪽 테이블에만 데이터가 있어도 결과를 만들어낼 수 있습니다.

- LEFT OUTER JOIN: 왼쪽 테이블의 모든 값이 출력되는 조인 (LEFT)
- RIGHT OUTER JOIN: 오른쪽 테이블의 모든 값이 출력되는 조인 (RIGHT)
- FULL OUTER JOIN: 왼쪽 또는 오른쪽 테이블의 모든 값이 출력되는 조인 (합집합)

```sql
SELECT 컬럼 목록
FROM 첫 번째 테이블(LEFT 테이블)
  <LEFT | RIGHT | FULL> OUTER JOIN 두 번째 테이블(RIGHT 테이블)
  ON 조인될 조건
WHERE 검색 조건
```

#### CROSS JOIN(상호 조인)

![상호 조인](https://hongong.hanbit.co.kr/wp-content/uploads/2021/11/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-SQL_CROSS-JOIN.png)
[출처: 혼공러들의 스터디 공간]

한쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인시키는 기능입니다. 상호 조인 결과의 전체 행의 개수는 두 테이블의 각 행의 개수를 곱한 수 만큽 됩니다. 카티션 곱(CARTESIAN PRODUCT)라고도 합니다.

```sql
SELECT *
FROM 첫 번째 테이블
  CROSS JOIN 두 번째 테이블
```

#### SELF JOIN(자체 조인)

자체 조인은 자기 자신고 조인하므로 1개의 테이블을 사용합니다. 별칭을 이용해 조입합니다.

```sql
SELECT 컬럼 목록
FROM 테이블 별칭 A
  INNER JOIN 테이블 별칭 B
  ON 조인될 조건
WHERE 검색 조건
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 그룹화해서 데이터 조회하기 (GROUP BY)

GROUP BY는 동일한 값을 가진 컬럼을 그룹으로 묶어서 요약하기 위해 사용합니다. WHERE과 HAVING 모두 조건을 거는 용도로 사용하지만, WHERE는 그룹화 하기 전이고, HAVING은 그룹화 후에 거는 조건입니다.

```sql
-- 기본 문법
SELECT 컬럼이름
FROM 테이블 이름
WHERE 검색 조건
GROUP BY 컬럼 이름
  HAVING 그룹화한 결과에 걸 조건
```

GROUP BY는 아래와 같은 상황에 사용할 수 있습니다.

```sql
-- 컬럼 그룹화
SELECT 컬럼
FROM 테이블
GROUP BY 그룹화할 컬럼

-- 조건 처리 후에 컬럼 그룹화
SELECT 컬럼
FROM 테이블
WHERE 조건식
GROUP BY 그룹화할 컬럼

-- 조건 처리 후에 컬럼 그룹화 후에 조건 처리
SELECT 컬럼
FROM 테이블
WHERE 조건식
GROUP BY 그룹화할 컬럼
  HAVING 조건식

-- 정렬과 함께 사용 시에
SELECT 컬럼
FROM 테이블
[WHERE 조건식]
GROUP BY 그룹화할 컬럼
  [HAVING 조건식]
ORDER BY 컬럼 1 [, 컬럼2, 컬럼 3, ... ];
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### NULL 처리하기 (IFNULL, CASE, COALESCE)

열 값이 NULL인 경우 처리하기 위해 IFNULL, CASE, COALESCE와 같은 함수를 사용할 수 있습니다.

#### IFNULL

IFNULL은 해당 컬럼의 값이 NULL을 반환할 때, 다른 값으로 출력할 수 있도록 해줍니다.

```sql
-- 기본 구조
SELECT IFNULL(컬럼이름, 'NULL일 경우 대체 값') FROM 테이블이름;
```

예시로 다음과 같이 NAME이 NULL값일 때 'NONE'으로 출력할 수 있습니다.

```sql
SELECT IFNULL(NAME, "NONE") as NAME
FROM ANIMAL_INS
```

이를 대체하기 위해 IF 함수와 IS NULL 조건을 사용할 수도 있습니다.

```sql
SELECT IF(IS NULL(NAME), "NONE", NAME) AS NAME
FROM ANIMAL_INS
```

#### CASE

해당 컬럼 값을 조건식을 통해 True, False를 판단하여 조건에 맞게 컬럼 값을 변환할 때 사용하는 함수입니다.

```sql
-- 기본구조
CASE
  WHEN 조건식1 THEN 식1
  WHEN 조건식2 THEN 식2
  ...
  ELSE 조건에 맞지 않는 경우 실행할 식
END
```

예시로 다음과 같이 NAME이 NULL값일 때 'NONE'으로 출력할 수 있습니다.

```sql
SELECT
  CASE
    WHEN NAME IS NULL THEN 'NONE'
    ELSE NAME
  END AS NAME
FROM ANIMAL_INS
```

#### COALESCE

COALESCE는 지정한 표현식들 중에 NULL이 아닌 첫 번째 값을 반환합니다.
표현식은 여러 항목 지정이 가능하고, 처음으로 만나는 NULL이 아닌 값을 출력합니다.
표현식이 모두 NULL일 경우엔 결과도 NULL을 반환합니다.

```sql
SELECT COALESCE(컬럼이름1, 컬럼이름1이 NULL인 경우 대체할 값)
FROM 테이블
```

예를 들어 다음과 같이 사용할 수 있습니다.

```sql
SELECT COALESCE(NAME, 'NONE')
FROM ANIMAL_INS
```

COALESCE는 배타적 OR 관계 열에서 활용도가 높습니다. 테이블에서 두 개 이상의 컬럼 중 하나의 값만 가지는 데이터일 경우 등에서 사용할 수 있습니다.

```sql
SELECT COALESCE(컬럼이름1, 컬럼이름2, 컬럼이름3, 컬럼이름4)
FROM 테이블
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 여러 테이블의 데이터를 하나의 쿼리로 추출하기 (UNION, UNION ALL)

하나의 쿼리 안에 다양한 테이블의 정보를 담기 위해 서브 쿼리, 조인 등을 사용할 수 있습니다. 그러나 각각의 테이블의 내용을 동일한 컬럼에
담아서 표현하고 싶을 경우에는 UNION, UNION ALL을 사용할 수 있습니다.

#### UNION

UNION을 사용하는 방법은 간단합니다. 각 테이블에서 데이터를 추출하고 UNION을 통해 합쳐주면 됩니다.
그러나 가져오는 컬럼의 순서와 타입이 동일해야 한다는 것을 주의해야 합니다. 또, UNION은 중복 데이터를 출력하지 않습니다.

```sql
-- 기본 문법
SELECT 컬럼목록1
FROM 테이블1
UNION
SELECT 컬럼목록2
FROM 테이블2
```

#### UNION ALL

UNION ALL은 UNION과 비슷하지만 중복 데이터도 모두 출력합니다. 중복을 제거하지 않으므로 UNION보다 속도가 빠릅니다.

```sql
-- 기본 문법
SELECT 컬럼목록1
FROM 테이블1
UNION ALL
SELECT 컬럼목록2
FROM 테이블2
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 상위 n개 레코드 출력하기 (LIMIT)

LIMIT는 상위 n개의 레코드(행)만을 조회하기 위해서 사용합니다.

```sql
SELECT 컬럼이름
FROM 테이블
ORDER BY 정렬조건
LIMIT 조회할 개수(n)
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 집계함수 (COUNT, SUM, AVG, MIN, MAX)

집합의 개수나 합계가 궁금하다면 SQL이 제공하는 집계함수를 사용해서 간단하게 구할 수 있습니다.
주의할 것은 집계 함수들은 **기본적은 NULL값은 제외하고 센다**는 것입니다. 즉, NULL값을 제외하고 처리하기 때문에 이를 고려해서 사용해야 합니다.

#### COUNT

**레코드(행)의 개수를 구하기** 위해서 COUNT를 사용할 수 있습니다. COUNT 함수는 인자로 주어진 집합의 개수를 구해서 반환하는 역할을 합니다.

```sql
-- 기본 문법
COUNT(인자)
```

COUNT 함수는 다음과 같이 사용할 수 있습니다.

```sql
-- 모든 행의 개수. *을 인자로 받을 수 있는 집계 함수는 COUNT가 유일합니다.
SELECT COUNT(*)
FROM 테이블

-- PLAYER들의 수 구하기
SELECT COUNT(PLAYER_ID)
FROM PLAYERS;
```

#### SUM

**집합의 합계를 구하기** 위해서는 SUM 함수를 사용할 수 있습니다. 예를 들어 1, 2, 3이라는 세개의 값을 가진 컬럼이 있다면, SUM 함수를 사용하면 6이라는 결과를 반환합니다.

```sql
-- 기본 문법
SUM(컬럼이름)
```

예를 들어 SUM는 다음과 같이 사용할 수 있습니다.

```sql
-- 플레이어들의 몸무게 총합 구하기
SELECT SUM(WEIGHT)
FROM PLAYERS;
```

#### AVG

**평균값을 구하기** 위해서는 AVG 함수를 사용할 수 있습니다.

```sql
-- 기본 문법
AVG(컬럼이름)
```

예를 들어 AVG는 다음과 같이 사용할 수 있습니다.

```sql
-- PLAYER들의 몸무게 평균 구하기
SELECT AVG(WEIGHT)
FROM PLAYERS;

-- 위 코드는 다음과 같습니다.
SELECT SUM(WEIGHT) / COUNT(WEIGHT)
FROM PLAYERS;
```

집계함수는 NULL인 값은 제외하고 연산하기 때문에 AVG도 NULL 값을 가진 행은 제외하고 평균을 냅니다.
그렇기 때문에 NULL 값을 0으로 치환한 후에 평균에 반영되도록 코드를 짤 수도 있습니다.

```sql
SELECT AVG(IFNULL(WEIGHT, 0))
FROM PLAYERS;
```

#### MIN, MAX

집합에서 최솟값과 최댓값을 구하기 위해서는 MIN, MAX함수를 사용할 수 있습니다. 다른 집계 함수들과 달리 문자열과 날짜형에도 사용이 가능합니다.

```sql
MIN(컬럼이름)
MAX(컬럼이름)
```

예를 들어 MIN, MAX는 다음과 같이 사용할 수 있습니다.

```sql
-- 플레이어들의 몸무게 중 최솟값 구하기
SELECT MIN(WEIGHT)
FROM PLAYERS;

-- 플레이어들의 몸무게 중 최댓값 구하기
SELECT MAX(WEIGHT)
FROM PLAYERS;
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 중복 행 제거하기 (DISTINCT)

컬럼에서 중복된 값을 가진 행들을 제거하기 위해서 DISTINT를 사용할 수 있습니다. DISTINCT는 모든 집계함수에 사용이 가능합니다.

```sql
-- 기본 문법
SELECT DISTINCT 컬럼 목록
FROM 테이블
```

DISTINCT 는 다음과 같이 사용할 수 있습니다.

```sql
-- 선수들의 중복을 제외한 국적 출력하기
SELECT DISTINCT COUNTRY
FROM PLAYERS

-- COUNTRY와 AFFILIATION이 같은 값을 가진 행들을 제외
SELECT DISTINCT COUNTRY, AFFILIATION
FROM PLAYERS

-- 집계함수와 사용하기. COUNT가 먼저 연산된 후에 DISTINCT가 적용됩니다.
SELECT DISTINCT COUNT(COUNTY)
FROM PLAYERS

-- 그러므로 이렇게 사용해줘야 옳은 표현입니다.
SELECT COUNT(DISTINCT COUNTY)
FROM PLAYERS
```

<br />

[⬆ Back to SQL](#sql-문법-목차)
<br />

### 임시 테이블 만들기 (WITH, WITH RECURSIVE)

#### WITH

SQL을 다루다보면 새로운 데이터를 만들 때마다 테이블에 저장할 수 없습니다. WITH 절은 **SQL이 반복되어서 사용될 때 성능을 높이기 위해 사용**됩니다.
테이블을 만들지 않고 테이블을 만든 것과 만든 효과를 내기 때문에 유용합니다. 하지만 메모리를 차지한다는 단점이 있습니다.

WITH 절을 사용하는 이유이자 WITH 절의 장점은 temp라는 임시 테이블을 사용해서 장시간 걸리는 쿼리의 결과를 저장해놓고 저장해놓은 데이터를 엑세스하기 때문에 성능이 좋기 때문입니다. 그렇다면 모두 WITH 절로 사용하면 되지 않는가? 라는 질문에 답하면 아닙니다. WITH 절을 너무 남발해서 같은 시간에 여러 개의 WITH 절을 동시에 돌리면 temp(임시 테이블)가 견딜 수 있는 정도가 넘어가서 다같이 느려지기 때문입니다.

```sql
-- 기본 문법
WITH 임시 테이블 이름 AS (
  테이블에 저장할 데이터
)

SELECT 컬럼 목록 FROM 임시 테이블 이름
```

예를 들어 WITH는 다음과 같이 사용할 수 있습니다.

```sql
# UNION 결과 : 1,2 출력
SELECT 1 AS num
UNION
SELECT 2 AS num;

# WITH, UNION 결과 : 1,2 출력
WITH test AS
(
  SELECT 1 AS num
  UNION ALL
  SELECT 2 AS num
)

SELECT * FROM test;

# WITH, UNION 결과 : 1,2,2,2,... (emp테이블의 행수만큼 2가 반복됩니다.)
WITH test AS
(
  SELECT 1 AS num
  UNION ALL
  SELECT 2 AS num FROM emp # 이 문장은 emp 테이블의 행수만큼 반복됩니다.
)

SELECT * FROM test;
```

#### WITH RECURSIVE

프로그래밍에 재귀 함수가 있듯이, SQL에도 재귀 쿼리가 존재합니다. WITH RECURSIVE문을 작성하고 내부에 UNION을 통해 재귀를 구성하는 것입니다.

```sql
#기본 문법
WITH RECURSIVE 테이블명 AS (
  SELECT 초깃값 AS 컬럼이름
  UNION [ALL]
  SELECT 컬럼이름 계산식 FROM 테이블명 WHERE 제어문
)

SELECT 컬럼 목록 테이블명
```

WITH RECURSIVE 절의 특징은 다음과 같습니다.

![with recursive](https://velog.velcdn.com/images%2Fcyanred9%2Fpost%2F9e362385-b421-4b65-90aa-3791fd6e50f2%2Fimage.png)

1. 메모리 상에 가상의 테이블을 저장합니다.
2. 반드시 UNION 사용해야합니다.
3. 반드시 비반복문(Non-Recursive)도 최소한 1개 요구되고, 처음 한번만 실행됩니다.
4. 서브 쿼리에서 바깥의 가상의 테이블을 참조하는 문장(반복문)이 반드시 필요합니다.
5. 반복되는 문장은 반드시 정지조건(Termination condition)이 요구됩니다.
6. 가상의 테이블을 구성하면서 그 자신(가상의 테이블)을 참조하여 값을 결정할 때 유용합니다.

WITH RECURSIVE는 다음과 같이 사용할 수 있습니다.

```sql
WITH RECURSIVE COUNTER AS (
  SELECT 1 NUM -- 재귀 초깃값
  UNION ALL
  SELECT NUM + 1 -- 재귀
  FROM COUNTER
  WHERE COUNTER < 5 -- 재귀 정지 조건
)

SELECT * FROM COUNTER -- NUM: 1 2 3 4 5
```

<br />

[⬆ Back to Top](#목차)
<br />

## 참고

- [혼공러들의 스터디 공간](https://hongong.hanbit.co.kr/sql-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-joininner-outer-cross-self-join/)
- [확장형 뇌 저장소](https://extbrain.tistory.com/56)
- [공부하는 식빵맘님 블로그](https://ansohxxn.github.io/db/ch6/)
- [Inpa Dev님 블로그](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-WITH-%EC%9E%84%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94)
