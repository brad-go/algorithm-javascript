# 효율적인 화폐 구성

[문제 링크](https://www.youtube.com/watch?v=5Lu34WIx2Us)

### 성능 요약

메모리: 128MB, 시간: 1초

### 문제

N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 종류의 화폐는 몇 개라도 사용할 수 있다.

예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 최소한의 화폐 개수이다.

M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램을 작성하시오.

### 입력

첫째 줄에 정수 X가 주어진다. (1 <= N <= 100, 1 <= M <= 10,000)
이후 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 최소 화폐 개수를 출력한다.
불가능할 때는 -1을 출력한다.

### 예제 입력

```
2 15
2
3
```

### 예제 출력

```
5
```

### 예제 입력 2

```
3 4
3
5
7
```

### 예제 출력 2

```
-1
```

### 예제 입력 3

```
3 7
2
3
5
```

### 예제 출력 3

```
2
```

<details><summary><b>문제 풀이</b></summary>
<div markdown="1">

### Solution

```js
const [n, m, ...currency] = require("fs")
  .readFileSync("./input2.txt")
  .toString()
  .trim()
  .split(/\s/)
  .map((v) => +v);

function Solution(n, m, currency) {
  const dp = new Array(m + 1).fill(m + 1);
  dp[0] = 0;

  for (let i = 0; i < n; i++) {
    for (let j = currency[i]; j < m + 1; j++) {
      if (dp[j - currency[i]] !== m + 1)
        dp[j] = Math.min(dp[j], dp[j - currency[i]] + 1);
    }
  }

  console.log(dp[m] === m + 1 ? -1 : dp[m]);
}

Solution(n, m, currency);
```

- dp 배열을 구하고자 하는 화폐크기만큼 길이로 생성하고 무한대 값을 의미할 m보다 큰 1로 채워준다.
- 0번째 인덱스는 사용하지 않으므로 0으로 초기화
- 각 화폐에 대한 값을 구하기 위해 화폐의 개수 만큼 반복문을 돈다.
- 그 안에서 반복문을 가지는데, 최소한 화폐 중 하나로는 나누어져야 하므로 화폐 크기부터 반복문을 시작한다.
- 구하고자 하는 인덱스 - 화폐가 무한(m+1)이 아니라면 현재 인덱스는 현재 인덱스의 값 혹은 현재 인덱스 - 화폐 + 1 중 작은 값으로 설정

</div>
</details>
