# algorithm-javascript

알고리즘에 대해 공부하고 정리하며 문제 풀이들을 기록하는 저장소

## 목차

- [동적 계획법](#dynamic-programming-동적-계획법)
- [LIS](#lis-최장-증가-부분-수열)
- [LCS](#lcs-알고리즘)

## Dynamic Programming (동적 계획법)

### 1. Dynamic Programming이란?

> **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**

기본적인 아이디어(점화식)로 **하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용**하는 풀이 방식으로 특정한 알고리즘이 아닌 하나의 문제해결 패러다임으로 볼 수 있다.

#### 1-1. 동적(Dynamic)이란?

- 자료구조에서 동적 할당(Dynamic Allocation)은 ‘**프로그램이 실행되는 도중에 실행한 메모리를 할당하는 기법**’
  → 메모리 공간이 필요할 때마다 필요한 만큼의 공간을 프로그램 실행 중에 할당하는 기법
- 반면에 **다이나믹 프로그래밍**에서 ‘다이나믹'은 별다른 의미 없이 사용된 단어

#### 1-2. DP를 사용하는 이유

일반적인 재귀 방식을 사용하면 작은 문제들이 여러 번 반복되어 비효율적인 계산이 될 수 있다. 예를 들어 피보나치 수열을 일반적인 재귀 방식으로 구현하면 다음과 같다.

```js
function fibo(n) {
  if (n < 2) return n;

  return fibo(n - 1) + fibo(n - 2);
}
```

식으로 표현하면 다음과 같다. `f(n) = f(n - 1) + f(n - 2)`

그런데 아래의 그림을 보자. 동일한 값을 또다시 여러번 구하게 되는 과정을 반복하게 된다. 이렇게 되면 n이 커지면 커질수록 피보나치 수를 구하기 위해 호출되는 함수의 횟수는 기하급수 적으로 증가한다.

<div align="center">
<img src="https://velog.velcdn.com/images%2Fjusung-c%2Fpost%2F88d6ff9a-422e-45e9-af65-e57af2e19815%2Fimage.png" />
</div>

그러나 한 번 구한 작은 문제의 결과 값을 **저장**해두고 재사용한다면, 이미 계산된 값을 다시 반복할 필요가 없다. 즉, 시간복잡도를 효율적으로 개선이 가능하다! `O(N^2) -> O(f(N))`

- **이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.**
- 다이나믹 프로그래밍을 이용해서 시간복잡도를 획기적으로 줄일 수 있는 경우가 많다.

<br />

### 2. DP의 사용 조건

#### 1. **최적 부분 구조 (Optimal Substructure)**

: 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있을 때 사용할 수 있다. 즉, **부분 문제의 최적 결과값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**를 의미한다.

예) 최적 경로 찾기

#### 2. **중복되는 부분 문제 (Overlapping Subproblem)**

: **동일한 작은 문제를 반복적으로 해결해야 할 때 사용**할 수 있다.

예) 피보나치 수열, 이진 탐색

<br />

### 3. DP로 문제 풀이하기

#### 3-1. 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하기

가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토하고 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려한다.

현재 해결하려는 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지 판단해야 한다. 즉, 위에서 쓴 조건들이 충족되는 문제인지 체크한다. 보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.

#### 3-2. 문제의 변수 파악

DP는 현재 변수에 따라 그 결과값을 찾고 그것을 전달하여 재사용하는 것을 거친다. 즉, 문제 내 변수의 개수를 알아내야 한다.

예를 들어 피보나치 수열에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다.

#### 3-3. 변수 간 관계식 만들기

변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다.

이러한 식을 **점화식**이라고 부르며 DP 문제 해결의 핵심이다. 이를 통해 짧은 코드 내에서 반복 / 재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.

예를 들어 피보나치 수열에서는 `f(n) = f(n-1) + f(n-2)`가 점화식이라고 볼 수 있다.

#### 3-4. 메모하기

점화식을 성공적으로 세웠다면, 변수의 값에 따른 결과를 저장해야 한다. 이것을 메모한다고 하여 **메모이제이션**(Memoization)이라고 한다.

메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나로 **한 번 계산한 결과를 메모리 공간에 메모하는 기법**이다. 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다. 값을 기록해 놓는다는 점에서 **캐싱**(Caching)이라고도 한다. **이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미**하므로 다이나믹 프로그래밍에 국한된 개념은 아니다.

변수 값에 따른 결과를 저장할 배열(일반적으로 dp 혹은 d라고 배열명을 짓는 것 같다) 등을 미리 만들고 그 결과가 나올 때마다 배열에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결할 수 있다.

#### 3-5. 기저 상태 파악하기

이제 가장 작은 문제의 상태를 알아야 한다.

피보나치 수열을 예시로 들면, `f(0) = 0`, `f(1) = 1`과 같은 것을 말한다. 이후 두 가지 수를 더해가며 값을 구하지만 기본적으로 가장 작은 문제는 위 두가지이다.

이 값을 파악하고 미리 배열에 저장해두면 된다. 문제에 따라 파악하기 쉽지 않을 수도 있다.

#### 3-6. 구현하기

이제 구현만 하면 된다. 구현 방식은 아래에서 살펴보자.

<br />

### 4. DP구현 방식

#### 4-1. **Top-Down (하향식)**

- 구현 방식에서 **재귀 함수**를 사용한다.
- **큰 문제를 해결하기 위해서 작은 문제를 재귀적으로 호출하여 그 작은 문제들이 모두 해결되었을 때, 실제로 큰 문제에 대한 답까지 얻을 수 있도록 코드를 작성**한다.
- 그 과정에서 한 번 계산된 결과값을 기록하기 위해 **메모이제이션 기법**을 사용한다.

#### 4-2. **Bottom-Up (상향식)**

- **아래 쪽에서 부터 작은 문제를 하나씩 해결해나가면서, 먼저 계산한 문제들의 값을 활용하여 다음의 문제를 해결하는 것**이 특징이다.
- **반복문**을 사용해서 해결한다.
- 다이나믹 프로그래밍의 전형적인 형태는 bottom-up방식이고, 결과 저장용 배열은 **DP 테이블**이라고 부른다.

<br />

### 5. 대표 문제

#### 피보나치 수열

각각의 피보나치 수를 구할 때 앞의 두 수를 더한 값을 사용. 각각의 항이 인접한 항들과 관계에 의한 값일 경우 **점화식을 사용해서 인접한 항들 사이의 관계식**을 구할 수 있다.

> a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub>
> , a<sub>1</sub>=1, a<sub>2</sub>=1

- 수열을 배열이나 리스트를 이용해 표현
- **시간복잡도**
  - 단순 재귀로 구현 시 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 된다. $O(2^n)$
  - 동일한 부분 문제가 반복적으로 호출된다. (**중복되는 부분 문제**)
  - 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 $O(N)$
- 다이나믹 프로그래밍의 사용 조건을 만족하는지?
  - 최적 부분 구조와 중복되는 부분 문제 조건을 둘 다 만족

**Tob-down (하향식)**

```tsx
const dp = new Array(n + 1).fill(0);

const fibo = (n) => {
  if (n === 0) return 0;
  else if (n === 1) return 1;

  if (dp[n] !== 0) return dp[n];

  dp[n] = fibo(n - 1) + fibo(n - 2);
  return dp[n];
};

console.log(fibo(n));
```

**Bottom-up(상향식)**

```tsx
const dp = new Array(n + 1).fill(0);

dp[0] = 0;
dp[1] = 1;

for (let i = 2; i < n + 1; i++) {
  dp[i] = dp[i - 1] + dp[i - 2];
}

console.log(dp[n]);
```

<br />

### 6. 다이나믹 프로그래밍 vs 분할 정복

- 다이나믹 프로그래밍과 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용할 수 있다.
  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
- 다이나믹 프로그래밍과 분할 정복의 차이점은 **부분 문제의 중복**이다.
  - 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
  - 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.

**[⬆ Back to Top](#목차)**
<br />

## LIS (최장 증가 부분 수열)

### LIS(Longest Increasing Subsequence) 알고리즘이란?

어떠한 수열이 주어질 때, 그 수열에서 일부 원소를 뽑아내어 새로 만든 수열을 ‘부분 수열'이라고 하며, 이 수열이 오름차순을 유지하면 ‘증가하는 부분 수열'이 된다.

**LIS**(**Longest Increasing Sequence**)는 특정 값들이 저장되어 있는 배열 형태에서 **순차적으로 증가하는 부분 수열 중 가장 길이가 긴 것**을 의미한다. 즉, 말 그대로 최장 증가 부분 수열이다.

예를 들어 아래와 같은 배열이 있다.

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |

여기서 가장 긴 증가하는 부분 수열, 즉 LIS는 어떤 걸 의미할까? 우선 각 숫자가 이전의 수들보다 크다면, 그 순서가 가장 큰 경우를 구해보자. 그 배열을 LIS라고 해보자.

우선 `i = 0`인 `arr[0] = 4`일 때, 자기 자신만 존재해도 수열을 만들 수 있고, 혼자서라도 LIS의 일부가 될 수 있으니 **1로 시작**할 수 있다.

`arr[1] = 2` → 2는 이전의 4보다 작다. 따라서 LIS는 1이다.

`arr[2] = 1` → 1은 이전의 2보다 작다. 따라서 LIS는 1이다.

`arr[3] = 3` → 3은 이전의 2보다 혹은 1보다 크니까 LIS는 2이다.

`arr[4] = 5` → 5는 4보다 크니까 LIS는 2, 또는 2, 3보다 크니까 LIS는 3, 또는 1, 3보다 크니까 LIS는 3이다. 해당 원소를 기준으로 가장 큰 것을 골라 LIS는 3이다.

`arr[5] = 8` → 8은 4, 5보다 크니까 LIS는 3, 또는 2, 3, 5보다 크니까 LIS는 4, 또는 1, 3, 5보다 크니까 LIS는 4다. 해당 원소를 기준으로 가장 큰 것을 골라 LIS는 4다.

`arr[6] = 6` → 6은 4, 5보다 크니까 LIS는 3, 또는 2, 3, 5보다 크니까 LIS는 4, 또는 1, 3, 5보다 크니까 LIS는 4다. 해당 원소를 기준으로 가장 큰 것을 골라 LIS는 4다.

`arr[7] = 7` → 7은 4, 5, 6보다 크니까 LIS는 4, 또는 2, 3, 5, 6보다 크니까 LIS는 5, 또는 1, 3, 5, 6보다 크니까 LIS는 5다. 해당 원소를 기준으로 가장 큰 것을 골라 LIS는 5다.

이제 아래를 확인해보자.

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 1   | 1   | 1   | 2   | 3   | 4   | 4   | 5   |

위 예제에서 가장 긴 부분 수열, 즉 LIS는 `[2, 3, 5, 6, 7]`이다. 위 예제를 통해 알게 된 최장 증가 부분 수열(LIS)에 대한 개념을 다시 정리해보자.

> **원소가 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, 각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 한다.**

눈치 챘을지 모르겠지만, 위 예제를 통해서 LIS는 부분적으로 여러개가 존재할 수 있다는 것을 알 수 있다. 위 예제에서 LIS는 `[1, 3, 5, 6, 7]`도 될 수 있다. 이와 같이 LIS는 반드시 하나로 결정되지 않는다. 하지만 **최대 길이 그 자체는 하나의 숫자로 정해진다**.

그러므로 **문제에서도 답**으로 **LIS의 길이를 출력**하도록 하거나, **수열을 구한다면 답이 여러 개가 되도록 출제**된다.

<br />

### 풀이 알고리즘

#### 1. 완전 탐색

단순하게 생각하면 그 배열 내에서 각 위치의 데이터를 기준으로 하나하나 다 비교하며 길이가 얼마나 되는지 확인하는 것이다. 즉, 배열 내 모든 증가 수열을 모두 파악하여 그 길이를 비교하는 방법을 수행하는 방식이다.

- 각 인덱스에서 시작해서 제일 증가하는 부분 수열을 찾아 **반복 + 재귀문**을 사용하여 푸는 방식
- 각 인덱스에서 시작해, 재귀를 통해 다시 호출하므로 전체 시간복잡도가 `O(2^N)`이 된다.

```tsx
const input = [4, 2, 1, 3, 5, 8, 6, 7];

function Solution(arr) {
  const N = arr.length;
  const LIS = new Array(N).fill(1); // LIS 길이 값을 저장하는 배열
  let MAX_LIS = 1; // LIS 길이 중 가장 긴 값을 저장

  // 완전 탐색 함수
  const searchExhaustive = (arr, idx) => {
    if (idx === 0) return 1; // 맨 처음 길이가 1일 때는 자기 자신만으로 LIS 구성, 1반환
    let value = 1; // 1에서 시작

    for (let i = idx - 1; i >= 0; i--) {
      // 현재 위치보다 이전 값들이 작다면 LIS의 대상이 될 수 있으니, 해당 위치 기준으로 재귀를 통해 지속 탐색 수행
      if (arr[i] < arr[idx])
        value = Math.max(value, searchExhaustive(arr, i) + 1);
    }

    return value;
  };

  // 각 인덱스마다 완전 탐색 실행하기
  for (let i = 0; i < N; i++) {
    LIS[i] = Math.max(LIS[i], searchExhaustive(arr, i));
    MAX_LIS = Math.max(MAX_LIS, LIS[i]); // 현재 까지의 최장 길이로 업데이트
  }

  // 최장 길이 출력
  console.log(`LIS 길이: ${MAX_LIS}`); // 5

  // 각 인덱스별 LIS 길이값 출력
  console.log(`각 인덱스의 LIS 길이: ${LIS}`); // 1, 1, 1, 2, 3, 4, 4, 5
}

Solution(input);
```

<br />

#### 2. DP

위의 완전 탐색 방식은 재귀를 통해 동일한 작은 문제가 반복되고 있고, 그 아래 작은 문제의 최적결과가 있다면 그대로 사용할 수 있다. 따라서 DP의 2가지 조건인 **Overlapping Subproblems**(중복 되는 부분 문제)와 **Optimal Structure**(최적 부분 구조)가 모두 충족되어 DP를 통해 해결할 수 있다.

문제를 정의하면 다음과 같다.

- **정의**: **길이 N의 배열에서 LIS의 길이 구하기**

DP를 해결하기 위해서는 **변수가 될 상태 값에 대해 이해하는 것이 중요**하다. 전체 배열은 N이지만, 작은 문제로 나누어서 생각한다면 배열의 길이가 1인 것부터 시작해서 그 최적값을 구해 전체 배열의 결과를 구할 수 있을 것이다. 따라서 **길이 그 자체가 상태값**이 된다.

상태가 1차원이므로 작은 문제들의 결과값, 즉 **DP의 결과를 저장할 1차원 배열**을 만들 수 있다. 그 크기는 기존 배열과 같게 생성하면 된다.

기저 상태는 어떻게 될까? 배열의 길이가 1일 때이다. 즉 N=1, index로는 0일 때, 그 자체만으로 LIS가 되므로 그 상태 지정을 할 수 있다.

- **기저 상태: LIS[0] = 1**

DP 문제를 해결하기 위해 가장 중요한 점화식을 알아보자. LIS의 특성에 따라 다음과 같은 점화식을 구할 수 있다.

- **점화식: LIS[i] = LIS[j] + 1 (단, j < i && arr[j] < arr[i])**

기존 배열이 `arr[]`일 때, 다음 2가지 조건을 충족해야 한다.

1. 현재 위치(i)보다 이전 위치(j)와 비교한다.
2. 현재 위치(i)의 값(`arr[i]`)보다 이전 위치(j)의 값 (`arr[j]`)가 더 작아야 한다.

##### 풀이 방식

1. 수열의 길이와 같은 LIS배열을 선언하고 1로 초기화한다.
2. 수열을 처음부터 끝까지 순서대로 1개씩 탐색한다. ( 현재 위치 = i )
   - 현재 위치(i)보다 이전에 있는 원소(j) 중에서 현재보다 작은지 체크한다.
   - 현재 원소보다 작다면, `LIS[j] + 1과 LIS[i]`의 크기를 비교해서 큰 것을 할당해준다. 현재 위치에서 각 원소(`arr[j]`)를 포함할 수 있는지 체크하고, 가능하면 길이는 늘어난다.
   - 이전 원소(j)번째 인덱스에서 끝나는 최장 증가 부분 수열의 마지막에 `arr[i]`를 추가했을 때의 LIS 길이와 추가하지 안고, 기존의 `LIS[i]`값 둘 중에 더 큰 값으로 `LIS[i]`값을 업데이트 한다.
3. dp 배열의 원소에서 가장 큰 값을 출력한다.

```tsx
const input = [4, 2, 1, 3, 5, 8, 6, 7];

function Solution(arr) {
  const N = arr.length;

  const LIS = new Array(N).fill(1);

  for (let i = 1; i < N; i++) {
    for (let j = 0; j < i; j++) {
      if (arr[j] < arr[i]) LIS[i] = Math.max(LIS[i], LIS[j] + 1);
    }
  }

  console.log(Math.max(...LIS));
}

Solution(input);
```

<details><summary><b>수열까지 구할 수 있는 코드</b></summary><div markdown="1">

<br />

```tsx
function Solution(arr) {
  const N = arr.length;

  const LIS = new Array(N);
  const V = new Array(N);

  const dp = () => {
    let max_lis = 0;
    let last = 0;

    for (let i = 0; i < LIS.length; i++) {
      LIS[i] = 1;
      V[i] = -1;

      for (let j = i - 1; j >= 0; j--) {
        if (arr[j] < arr[i] && LIS[j] >= LIS[i]) {
          LIS[i] = LIS[j] + 1;
          V[i] = j;
        }
        if (max_lis < LIS[i]) {
          max_lis = LIS[i];
          last = i;
        }
      }
    }
    return last;
  };

  const result = dp();
  console.log(`LIS 길이: ${LIS[result]}`);

  let LIS_LENGTH = "";
  for (let i = 0; i < LIS.length; i++) {
    LIS_LENGTH += LIS[i] + ", ";
  }
  console.log(`각 index의 LIS 값: ${LIS_LENGTH}`);

  let lis = "";
  const getLIS = (idx) => {
    if (V[idx] === -1) {
      lis += arr[idx] + " ";
      return;
    }
    getLIS(V[idx]);
    lis += arr[idx] + " ";
  };
  getLIS(result);

  console.log(`LIS 배열 출력: ${lis}`);
}

Solution(input);
```

</div></details><br />

위 코드에서 볼 수 있듯이 2중 반복문을 통해서 LIS를 구해 나가고 있다. 따라서 이와 같은 풀이 방식은 시간 복잡도가 `O(N^2)`가 된다. 완전 탐색보다는 낫지만, 여전히 높은 시간복잡도가 요구된다.

<br />

#### 3. 이분 탐색

여전히 높은 시간복잡도를 가지고 있는 풀이 방법을 개선하기 위해 **이분 탐색**을 사용할 수 있다. 이 해결법으로 `O(nlogn)`의 시간복잡도를 가질 수 있다. 즉, 원래의 `O(N^2)`의 알고리즘에서 이전의 원소들을 탐색하는 과정(`O(N)`)을 이분 탐색(`O(logn)`)을 이용해서 시간을 더 줄여주는 것이다.

여기서의 아이디어는 다음과 같다.

1. 추가 배열을 만들고 기존 배열을 탐색하며 큰 수는 추가 배열에 이어 붙인다.
2. 추가 배열의 마지막에 추가된 값보다 작은 값은 **이분 탐색**을 통해 적절한 자리를 찾아 교환한다.

**핵심 아이디어**는 LIS를 만들기 위해서 만드는 과정에서 **LIS의 마지막 원소가 가능한 작을 수록 더 긴 LIS를 생성할 수 있다**는 것이다. 그러므로 원소가 들어올 때, 만약 **현재 생성된 LIS의 원소보다 작은 경우, LIS에 들어갈 위치를 찾은 후(O(logn)) 원소를 대체**한다.

- **장점**: 이분 탐색을 통해 빠르게 LIS의 길이를 구할 수 있다.
- **단점**: LIS 배열 그 자체는 중간에 값이 교체되기 때문에 구할 수 없을 수도 있다.

예를 들어 다음과 같은 기존 배열 `arr[]`과 추가 배열 `LIS[]`가 있다.

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] |     |     |     |     |     |     |     |     |

1. 인덱스 0 탐색(arr[0])

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 4   |     |     |     |     |     |     |     |

- arr[0]은 최초의 값이므로 바로 LIS 배열에 추가한다.
- 현재 마지막 추가된 값: 10

2. 인덱스 1 탐색(arr[1])

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 2   |     |     |     |     |     |     |     |

- 이전 LIS 배열의 마지막 값은 4였다. arr[1] = 2로 이전 수보다 작은데, 순서 상 교체될 수 있는 위치는 `LIS[0]`이므로 교체한다.
- 현재 마지막 추가된 값: 2

3. 인덱스 2 탐색(arr[2])

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 1   |     |     |     |     |     |     |     |

- 이전 LIS 배열의 마지막 값은 2였다. arr[2] = 1로 이전 수보다 작은데, 순서 상 교체될 수 있는 위치는 `LIS[0]`이므로 교체한다.
- 현재 마지막 추가된 값: 1

4. 인덱스 3 탐색(arr[3])

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 1   | 3   |     |     |     |     |     |     |

- 이전 LIS 배열의 마지막 값은 1이었다. arr[3] = 3로 이전 수보다 크기 때문에 바로 LIS 배열에 추가할 수 있다.
- 현재 마지막 추가된 값: 3

5. 인덱스 4 탐색(arr[4])

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 1   | 3   | 5   |     |     |     |     |     |

- 이전 LIS 배열의 마지막 값은 3이었다. arr[4] = 5로 이전 수보다 크기 때문에 바로 LIS 배열에 추가할 수 있다.
- 현재 마지막 추가된 값: 5

6. 인덱스 5 탐색(arr[5])

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 1   | 3   | 5   | 8   |     |     |     |     |

- 이전 LIS 배열의 마지막 값은 5였다. arr[5] = 8로 이전 수보다 크기 때문에 바로 LIS 배열에 추가할 수 있다.
- 현재 마지막 추가된 값: 8

7. 인덱스 6 탐색(arr[6])

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 1   | 3   | 5   | 6   |     |     |     |     |

- 이전 LIS 배열의 마지막 값은 8이었다. arr[6] = 6로 이전 수보다 작은데, 순서 상 교체될 수 있는 위치는 `LIS[3]`이므로 교체한다.
- 현재 마지막 추가된 값: 6

8. 인덱스 7 탐색(arr[7])

| Index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| arr[i] | 4   | 2   | 1   | 3   | 5   | 8   | 6   | 7   |
| LIS[i] | 1   | 3   | 5   | 6   | 7   |     |     |     |

- 이전 LIS 배열의 마지막 값은 6이었다. arr[7] = 7로 이전 수보다 크기 때문에 바로 LIS 배열에 추가할 수 있다.
- 현재 마지막 추가된 값: 7

위와 같이 구한 결과 전체 LIS의 길이는 5라는 것을 알 수 있다. 하지만 위에서 단점에 대해 설명했듯이, 중간에 교체되어 LIS배열이 실제 LIS라고 볼 수 없게 된다.

##### 길이만 출력

```tsx
function Solution(arr) {
  const N = arr.length;
  const LIS = new Array(N);
  LIS[0] = arr[0]; // 최초 인덱스 0의 값은 arr[0]

  // 반복문을 이용한 이진 탐색
  const binarySearch = (arr, x) => {
    let start = 0;
    let end = arr.length - 1;

    // 현재 탐색한 위치가 찾고하자 하는 값도다 크냐 작냐에 따라 중간 idx 계산을 위한 start / end값을 업데이트
    while (start < end) {
      const mid = Math.ceil((start + end) / 2);
      if (arr[mid] === x) return mid;

      if (arr[mid] < x) start = mid + 1;
      else end = mid - 1;
    }

    // 일치값을 찾지 못했을 때, -1이 아니라 그 적절한 위치를 반환해야 함
    return start;
  };

  let idx = 0;

  for (let i = 1; i < N; i++) {
    // 기존 배열이 탐색 중 더 큰 숫자라면 뒤에 이어 붙이기
    if (LIS[idx] < arr[i]) {
      LIS[++idx] = arr[i];
      continue;
    }

    // 그렇지 않고 작다면 이진 탐색을 통해 교체 수행
    const target_idx = binarySearch(LIS, arr[i]);
    LIS[target_idx] = arr[i];
  }

  console.log("LIS 길이: " + (idx + 1));
}

Solution(input);
```

##### 실제 LIS 출력

실제 LIS를 출력하고 싶다면 약간의 수정이 필요하다.

```tsx
function Solution(arr) {
  const N = arr.length;
  const LIS = new Array(N);
  LIS[0] = arr[0];

  // 몇번째 인덱스가 LIS에 들어가는 지 저장할 배열
  const record = new Array(N);
  record[0] = 0; // 시작 값은 무조건 0번째 인덱스

  const binarySearch = (arr, x) => {
    let start = 0;
    let end = arr.length - 1;

    while (start < end) {
      const mid = Math.ceil((start + end) / 2);
      if (arr[mid] === x) return mid;

      if (arr[mid] < x) start = mid + 1;
      else end = mid - 1;
    }

    return start;
  };

  let idx = 0;

  for (let i = 1; i < N; i++) {
    if (LIS[idx] < arr[i]) {
      LIS[++idx] = arr[i];
      // 각 수가 LIS 배열에 들어갈 때, 몇번째 인덱스에 들어가는 지를 record라는 리스트에 저장
      record[i] = idx;
      continue;
    }

    const target_idx = binarySearch(LIS, arr[i]);
    LIS[target_idx] = arr[i];
    // 각 수가 LIS 배열에 들어갈 때, 몇번째 인덱스에 들어가는 지를 record라는 리스트에 저장
    record[i] = target_idx;
  }

  console.log("LIS 길이: " + (idx + 1));

  // 실제 LIS 수열을 담을 배열
  const LIS_RESULT = [];

  // record가 다 차면 최대값으로부터 역순으로 순회하여 그 인덱스에 해당하는 값을 LIS_RESULT에 저장
  for (let i = N - 1; i >= 0; i--) {
    // 증가되어 있는 idx(4)가 record[i](몇번째 인덱스에 들어간지)와 같으면 LIS_RESULT에 기존 배열에서 찾아서 저장
    if (idx === record[i]) {
      LIS_RESULT[idx] = arr[i];
      // 해당 번째 수를 찾았으면 idx를 낮춰서 다음 거에서 찾기
      idx--;
    }
  }

  console.log("실제 LIS 출력: " + LIS_RESULT);
}

Solution(input);
```

**[⬆ Back to Top](#목차)**
<br />

## LCS 알고리즘

LCS는 주로 **최장 공통 부분 수열(Longest Common Subsequence)**을 말하지만, **최장 공통 문자열(Longest Common Substring)**을 말하기도 한다.

문자열 ABCDEF와 GBCDFE를 이용해 차이점을 예시로 들어보면

![https://velog.velcdn.com/images%2Femplam27%2Fpost%2F14e1f11d-d3de-4dd3-8f41-3e7f9697770f%2F%EB%91%98%20%EC%B0%A8%EC%9D%B4.png](https://velog.velcdn.com/images%2Femplam27%2Fpost%2F14e1f11d-d3de-4dd3-8f41-3e7f9697770f%2F%EB%91%98%20%EC%B0%A8%EC%9D%B4.png)

해당 예시에서 **최장 공통 부분수열(Longest Common Subsequence)**은 **BCDF**, **BCDE**가 될 수 있다. 부분 수열이기 때문에 문자 사이를 건너뛰어 공통되면서 가장 긴 부분인 문자열을 찾으면 된다. **최장 공통 문자열(Longest Common Substring)**은 **BCD**이다. 부분문자열이 아니기 때문에 한번에 이어져있는 문자열만 가능하다.

### 최장 공통 문자열(Longest Common Substring)

최장 공통 부분수열(Longest Common Subsequence)을 구하기 전에 최장 공통 문자열을 먼저 보도록 하자. 해당 과정이 더 쉽고, 최장 공통 부분 수열을 구하는데 사용되기 때문이다.

#### 점화식

```tsx
if (string_A[i] === string_B[j]) LCS[i][j] = LCS[i - 1][j - 1] + 1;
```

최장 공통 문자열의 점화식을 위처럼 작성할 수 있다. LCS라는 2차원 배열을 이용하여 두 문자열을 행, 열에 매칭한다. LCS 배열은 편의상 0으로 채워준다. 이후 i, j가 1이상일 때부터 검사를 시작한다. 검사 순서는 다음과 같다.

1. 문자열 A, 문자열 B의 한글자씩 비교해본다.
2. 두 문자가 **같다면** `LCS[i - 1][j - 1]` 값을 찾아 `+1` 한다.
3. 위 과정을 반복한다.

위 과정이 성립하는 이유는 공통 문자열은 연속되어야 하기 때문이다. 현재 두 문자가 같을 때, 두 문자의 앞글자까지가 공통 문자열이라면 계속 공통 문자열이 이어질 것이고, 아니라면 해당 문자부터 다시 공통 문자열을 만들어 가게 될 것이다.

<details><summary><b>구현 과정 보기</b></summary><div markdown="LCS_1">
<br />

1. **앞 마진이 0인 2차원 배열을 생성, ABCDEF 문자열과 GBCDFE 문자열을 한 글자 씩 비교**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   |     |     |     |     |     |     |
   | 2   | B   | 0   |     |     |     |     |     |     |
   | 3   | C   | 0   |     |     |     |     |     |     |
   | 4   | D   | 0   |     |     |     |     |     |     |
   | 5   | F   | 0   |     |     |     |     |     |     |
   | 6   | E   | 0   |     |     |     |     |     |     |

2. **G를 ABCDEF와 한 글자 씩 비교, 같은 문자가 없기 때문에 LCS[i][j] 값은 모두 `0`으로 채워 짐**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   |     |     |     |     |     |     |
   | 3   | C   | 0   |     |     |     |     |     |     |
   | 4   | D   | 0   |     |     |     |     |     |     |
   | 5   | F   | 0   |     |     |     |     |     |     |
   | 6   | E   | 0   |     |     |     |     |     |     |

3. **다음 B를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1     | 2     | 3   | 4   | 5   | 6   |
   | --- | --- | --- | ----- | ----- | --- | --- | --- | --- |
   | j   | -   | -   | A     | B     | C   | D   | E   | F   |
   | 0   | -   | 0   | 0     | 0     | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | **0** | 0     | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0     | **1** | 0   | 0   | 0   | 0   |
   | 3   | C   | 0   |       |       |     |     |     |     |
   | 4   | D   | 0   |       |       |     |     |     |     |
   | 5   | F   | 0   |       |       |     |     |     |     |
   | 6   | E   | 0   |       |       |     |     |     |     |

   - LCS[1][1] = 0, LCS[2][2] = 0 + 1 = 1
     <br />

4. **다음 C를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1   | 2     | 3     | 4   | 5   | 6   |
   | --- | --- | --- | --- | ----- | ----- | --- | --- | --- |
   | j   | -   | -   | A   | B     | C     | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | **1** | 0     | 0   | 0   | 0   |
   | 3   | C   | 0   | 0   | 0     | **2** | 0   | 0   | 0   |
   | 4   | D   | 0   |     |       |       |     |     |     |
   | 5   | F   | 0   |     |       |       |     |     |     |
   | 6   | E   | 0   |     |       |       |     |     |     |

   - LCS[2][2] = 1, LCS[3][3] = 1 + 1 = 2
     <br />

5. **다음 D를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1   | 2   | 3     | 4     | 5   | 6   |
   | --- | --- | --- | --- | --- | ----- | ----- | --- | --- |
   | j   | -   | -   | A   | B   | C     | D     | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0     | 0     | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0     | 0     | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 0     | 0     | 0   | 0   |
   | 3   | C   | 0   | 0   | 0   | **2** | 0     | 0   | 0   |
   | 4   | D   | 0   | 0   | 0   | 0     | **3** | 0   | 0   |
   | 5   | F   | 0   |     |     |       |       |     |     |
   | 6   | E   | 0   |     |     |       |       |     |     |

   - LCS[3][3] = 2, LCS[4][4] = 2 + 1 = 3
     <br />

6. **다음 F를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5     | 6     |
   | --- | --- | --- | --- | --- | --- | --- | ----- | ----- |
   | j   | -   | -   | A   | B   | C   | D   | E     | F     |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0     | 0     |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0     | 0     |
   | 2   | B   | 0   | 0   | 1   | 0   | 0   | 0     | 0     |
   | 3   | C   | 0   | 0   | 0   | 2   | 0   | 0     | 0     |
   | 4   | D   | 0   | 0   | 0   | 0   | 3   | **0** | 0     |
   | 5   | F   | 0   | 0   | 0   | 0   | 0   | 0     | **1** |
   | 6   | E   | 0   |     |     |     |     |       |       |

   - LCS[5][4] = 0, LCS[6][5] = 0 + 1 = 1
     <br />

7. **다음 E를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1   | 2   | 3   | 4     | 5     | 6   |
   | --- | --- | --- | --- | --- | --- | ----- | ----- | --- |
   | j   | -   | -   | A   | B   | C   | D     | E     | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0     | 0     | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0     | 0     | 0   |
   | 2   | B   | 0   | 0   | 1   | 0   | 0     | 0     | 0   |
   | 3   | C   | 0   | 0   | 0   | 2   | 0     | 0     | 0   |
   | 4   | D   | 0   | 0   | 0   | 0   | 3     | 0     | 0   |
   | 5   | F   | 0   | 0   | 0   | 0   | **0** | 0     | 1   |
   | 6   | E   | 0   | 0   | 0   | 0   | 0     | **1** | 0   |

   - LCS[4][5] = 0, LCS[5][6] = 0 + 1 = 1
     <br />

8. **최댓값을 찾으면 Longest Common Substring 탐색 종료**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 0   | 0   | 0   | 0   |
   | 3   | C   | 0   | 0   | 0   | 2   | 0   | 0   | 0   |
   | 4   | D   | 0   | 0   | 0   | 0   | 3   | 0   | 0   |
   | 5   | F   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |
   | 6   | E   | 0   | 0   | 0   | 0   | 0   | 1   | 0   |

</div></details>
<br />

### 최장 공통 부분 수열(Longest Common Subsequence)

이번에는 최장 공통 부분 수열을 만들어보자.

#### 점화식

```tsx
if (string_A[i] === string_B[j]) LCS[i][j] = LCS[i - 1][j - 1] + 1;
else LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
```

최장 공통 부분 수열의 점화식을 작성해봤다. 위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사한다.

1. 문자열 A, 문자열 B의 한글자씩 비교한다.
2. 두 문자가 **같다면** `LCS[i - 1][j - 1]` 값을 찾아 `+1` 한다.
3. 두 문자가 **다르다면** `LCS[i - 1][j]`와 `LCS[i][j - 1]` 중에 큰 값을 표시한다.
4. 위 과정을 반복한다.

최장 공통 문자열을 구하는 과정과 다른 부분은 비교하는 두 문자가 다른 때이다. 비교하는 두 문자가 같을 때는 같은 과정을 보인다. **왜 어떤 부분은 다른 로직을, 어떤 부분은 같은 로직을 사용할까?**

#### 1. LCS[i - 1][j]와 LCS[i][j - 1]는 어떤 의미인가?

**부분수열은 연속된 값이 아니다**. 때문에 현재의 문자를 비교하는 과정 이전의 최대 공통 부분수열은 **계속 유지된다**. ‘현재의 문자를 비교하는 과정' 이전의 과정이 바로 `LCS[i - 1][j]`와 `LCS[i][j - 1]`가 된다.

| -   | i   | 0   | 1   | 2     | 3     | 4   | 5   | 6   |
| --- | --- | --- | --- | ----- | ----- | --- | --- | --- |
| j   | -   | -   | A   | B     | C     | D   | E   | F   |
| 0   | -   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
| 1   | G   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
| 2   | B   | 0   | 0   | **1** | 0     | 0   | 0   | 0   |
| 3   | C   | 0   | 0   | `1`   | **2** | 2   | 2   | 2   |
| 4   | D   | 0   |     |       |       |     |     |     |
| 5   | F   | 0   |     |       |       |     |     |     |
| 6   | E   | 0   |     |       |       |     |     |     |

문자열 **AB**와 **GBC**를 비교(위 표의 코드로 표시된 1부분)하는 과정을 예로 들어보자. AB와 GBC의 최대 공통 부분 수열이 **B**라는 것을 알기 위해서는 **문자열 A와 GBC를 비교하는 과정, 문자열 AB와 GB를 비교하는 과정**이 필요하다. 문자열 **AB**와 **GB**의 비교 과정에서 최대 공통 부분 수열이 **B**임을 확인했기 때문에 문자열 **AB**와 **GBC**의 최대 공통 부분수열 역시 **B**가 된다.

![https://velog.velcdn.com/images%2Femplam27%2Fpost%2Ff44bccfc-9da2-4da1-80a0-c3ae9c1e9cbe%2F%EA%B3%BC%EC%A0%951.png](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Ff44bccfc-9da2-4da1-80a0-c3ae9c1e9cbe%2F%EA%B3%BC%EC%A0%951.png)

#### 2. 왜 문자가 같으면 LCS[i][j] = LCS[i - 1][j - 1] + 1인가?

최대 공통 문자열을 구할 때, 비교하는 문자가 같으면 LCS[i][j] = LCS[i - 1][j - 1] + 1의 과정을 거쳤다. 이 과정이 어떻게 최대 공통 부분 수열에도 똑같이 적용될까? 부분 수열이 연속될 필요가 없음을 위 과정에서 여러번 보았다. 그렇다면 답은 간단하다. 두 문자가 같은 상황이 오면 지금까지의 최대 공통 부분 수열에 1을 더해주는 것이다.

| -   | i   | 0   | 1   | 2   | 3     | 4   | 5   | 6   |
| --- | --- | --- | --- | --- | ----- | --- | --- | --- |
| j   | -   | -   | A   | B   | C     | D   | E   | F   |
| 0   | -   | 0   | 0   | 0   | 0     | 0   | 0   | 0   |
| 1   | G   | 0   | 0   | 0   | 0     | 0   | 0   | 0   |
| 2   | B   | 0   | 0   | `1` | 0     | 0   | 0   | 0   |
| 3   | C   | 0   | 0   | `1` | **2** | 2   | 2   | 2   |
| 4   | D   | 0   |     |     |       |     |     |     |
| 5   | F   | 0   |     |     |       |     |     |     |
| 6   | E   | 0   |     |     |       |     |     |     |

문자열 **ABC**와 **GBC**를 비교(위 표에서 코드로 기입된 숫자 부분)하는 과정을 예로 들어보자. LCS 배열은 `LCS[i - 1][j]`와 `LCS[i][j - 1]`의 비교를 통해 언제나 본인까지의 최대 공통 부분수열 값을 가지고 있다. 문자열 **AB**와 **GB**를 비교할 때와 문자열 **ABC**와 **GBC**를 비교할 때 달라진 점은 두 문자열 모두에 **C**가 추가된 점이다. 때문에 기존의 최대 공통 부분 수열인 **B**에 **C**를 더한 **BC**가 최대 공통 부분 수열이 되는 것이다.

> **ABC**와 **GBC**의 최장 공통 부분 수열 = **AB**와 **GB**의 최장 공통 부분수열 + 1

<details><summary><b>구현 과정 보기</b></summary><div markdown="LCS_1">
<br />

1. **앞 마진이 0인 2차원 배열을 생성, ABCDEF 문자열과 GBCDFE 문자열을 한 글자 씩 비교**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   |     |     |     |     |     |     |
   | 2   | B   | 0   |     |     |     |     |     |     |
   | 3   | C   | 0   |     |     |     |     |     |     |
   | 4   | D   | 0   |     |     |     |     |     |     |
   | 5   | F   | 0   |     |     |     |     |     |     |
   | 6   | E   | 0   |     |     |     |     |     |     |

2. **G를 ABCDEF와 한 글자 씩 비교, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   |     |     |     |     |     |     |
   | 3   | C   | 0   |     |     |     |     |     |     |
   | 4   | D   | 0   |     |     |     |     |     |     |
   | 5   | F   | 0   |     |     |     |     |     |     |
   | 6   | E   | 0   |     |     |     |     |     |     |

3. **다음 B를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`**

   | -   | i   | 0   | 1     | 2     | 3   | 4   | 5   | 6   |
   | --- | --- | --- | ----- | ----- | --- | --- | --- | --- |
   | j   | -   | -   | A     | B     | C   | D   | E   | F   |
   | 0   | -   | 0   | 0     | 0     | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | **0** | 0     | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0     | **1** | 1   | 1   | 1   | 1   |
   | 3   | C   | 0   |       |       |     |     |     |     |
   | 4   | D   | 0   |       |       |     |     |     |     |
   | 5   | F   | 0   |       |       |     |     |     |     |
   | 6   | E   | 0   |       |       |     |     |     |     |

   - LCS[1][1] = 0, LCS[2][2] = 0 + 1 = 1
     <br />

4. **다음 C를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2     | 3     | 4   | 5   | 6   |
   | --- | --- | --- | --- | ----- | ----- | --- | --- | --- |
   | j   | -   | -   | A   | B     | C     | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0     | 0     | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | **1** | 0     | 0   | 0   | 0   |
   | 3   | C   | 0   | 0   | 1     | **2** | 2   | 2   | 2   |
   | 4   | D   | 0   |     |       |       |     |     |     |
   | 5   | F   | 0   |     |       |       |     |     |     |
   | 6   | E   | 0   |     |       |       |     |     |     |

   - LCS[2][2] = 1, LCS[3][3] = 1 + 1 = 2
     <br/ >

5. **다음 D를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2   | 3     | 4     | 5   | 6   |
   | --- | --- | --- | --- | --- | ----- | ----- | --- | --- |
   | j   | -   | -   | A   | B   | C     | D     | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0     | 0     | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0     | 0     | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 1     | 1     | 1   | 1   |
   | 3   | C   | 0   | 0   | 1   | **2** | 2     | 2   | 2   |
   | 4   | D   | 0   | 0   | 1   | 2     | **3** | 3   | 3   |
   | 5   | F   | 0   |     |     |       |       |     |     |
   | 6   | E   | 0   |     |     |       |       |     |     |

   - LCS[3][3] = 2, LCS[4][4] = 2 + 1 = 3
     <br />

6. **다음 F를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5     | 6     |
   | --- | --- | --- | --- | --- | --- | --- | ----- | ----- |
   | j   | -   | -   | A   | B   | C   | D   | E     | F     |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0     | 0     |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0     | 0     |
   | 2   | B   | 0   | 0   | 1   | 1   | 1   | 1     | 1     |
   | 3   | C   | 0   | 0   | 1   | 2   | 2   | 2     | 2     |
   | 4   | D   | 0   | 0   | 1   | 2   | 3   | **3** | 3     |
   | 5   | F   | 0   | 0   | 1   | 2   | 3   | 3     | **4** |
   | 6   | E   | 0   |     |     |     |     |       |       |

   - LCS[5][4] = 3, LCS[6][5] = 3 + 1 = 4
     <br />

7. **다음 E를 ABCDEF와 한 글자 씩 비교, 같은 문자가 존재하면 LCS[i][j] 값은 `LCS[i - 1][j - 1] + 1`, 문자가 다르다면 LCS[i][j] 값은 `max(LCS[i - 1][j], LCS[i][j - 1])`**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 1   | 1   | 1   | 1   |
   | 3   | C   | 0   | 0   | 1   | 2   | 2   | 2   | 2   |
   | 4   | D   | 0   | 0   | 1   | 2   | 3   | 3   | 3   |
   | 5   | F   | 0   | 0   | 1   | 2   | 3   | 3   | 4   |
   | 6   | E   | 0   | 0   | 1   | 2   | 3   | 4   | 4   |

   - LCS[4][5] = 3, LCS[5][6] = 3 + 1 = 4
     <br />

8. **최댓값을 찾으면 Longest Common Substring 탐색 종료**

   | -   | i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
   | --- | --- | --- | --- | --- | --- | --- | --- | --- |
   | j   | -   | -   | A   | B   | C   | D   | E   | F   |
   | 0   | -   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 1   | G   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
   | 2   | B   | 0   | 0   | 1   | 1   | 1   | 1   | 1   |
   | 3   | C   | 0   | 0   | 1   | 2   | 2   | 2   | 2   |
   | 4   | D   | 0   | 0   | 1   | 2   | 3   | 3   | 3   |
   | 5   | F   | 0   | 0   | 1   | 2   | 3   | 3   | 4   |
   | 6   | E   | 0   | 0   | 1   | 2   | 3   | 4   | 4   |

</div></details>
<br />

### 최장 공통 부분 수열(Longest Common Subsequence) 찾기

위에서 LCS 구현 과정을 통해 LCS 배열을 만들며 LCS의 길이를 알았다. 이제 만든 LCS 배열을 이용해 최장 공통 부분 수열의 값을 찾아보자. 경우에 따라 여러가지 답이 나올 수 있다.

과정은 다음과 같다.

1. LCS 배열의 **가장 마자막 값에서 시작**한다. 결과값을 저장할 `result` 배열을 준비한다.
2. `LCS[i - 1][j]`와 `LCS[i][j - 1]` 중 현재 값과 같은 값을 찾는다.
   1. 만약 **같은 값이 있다면 해당 값으로 이동**한다.
   2. 만약 **같은 값이 없다면 `result` 배열에 해당 문자를 넣고 `LCS[i - 1][j - 1]`로 이동**한다.
3. 2번 과정을 반복하다가 0으로 이동하게 되면 종료한다.
4. `result` 배열의 역순이 **LCS**이다.

```tsx
const string_A = "ABCDEF";
const string_B = "GBCDFE";

const LCS = Array.from(Array(string_A.length), () =>
  Array(string_B.length).fill(0)
);

for (let i = 1; i < string_A.length; i++) {
  for (let j = 1; j < string_B.length; j++) {
    LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
    if (string_A[i] === string_B[j]) LCS[i][j] = LCS[i - 1][j - 1] + 1;
  }
}

// LCS 결과를 담을 배열 선언
const result = [];

let r = string_A.length - 1;
let c = string_B.length - 1;

// 배열의 가장 마지막 값에서 시작하여 LCS[r - 1][c]와 LCS[r][c - 1] 중 현재 값과 같은 값 찾기
while (LCS[r][c] !== 0) {
  // 위 인덱스가 현재값과 같은 길이를 가졌다면 위로 이동
  if (LCS[r][c] === LCS[r - 1][c]) {
    r--;
    continue;
  }
  // 왼쪽 인덱스가 현재값과 같은 길이를 가졌다면 왼쪽으로 이동
  if (LCS[r][c] === LCS[r][c - 1]) {
    c--;
    continue;
  }

  // 두 조건에 해당하지 않는다면 두 문자열이 같은 값을 가진 것. result 배열에 넣어주기
  result.push(string_A[r]);
  r--;
  c--;
}

console.log(result.reverse());
```

**[⬆ Back to Top](#목차)**
<br />

## 참고

- [겐지충님 블로그](https://hongjw1938.tistory.com/58?category=909529)
- [emplam27 블로그](https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-Subsequence)
