# algorithm-javascript

알고리즘에 대해 공부하고 정리하며 문제 풀이들을 기록하는 저장소

## 목차

- [동적 계획법](#dynamic-programming-동적-계획법)

## Dynamic Programming (동적 계획법)

### 1. Dynamic Programming이란?

> **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**

기본적인 아이디어(점화식)로 **하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용**하는 풀이 방식으로 특정한 알고리즘이 아닌 하나의 문제해결 패러다임으로 볼 수 있다.

#### 1-1. 동적(Dynamic)이란?

- 자료구조에서 동적 할당(Dynamic Allocation)은 ‘**프로그램이 실행되는 도중에 실행한 메모리를 할당하는 기법**’
  → 메모리 공간이 필요할 때마다 필요한 만큼의 공간을 프로그램 실행 중에 할당하는 기법
- 반면에 **다이나믹 프로그래밍**에서 ‘다이나믹'은 별다른 의미 없이 사용된 단어

#### 1-2. DP를 사용하는 이유

일반적인 재귀 방식을 사용하면 작은 문제들이 여러 번 반복되어 비효율적인 계산이 될 수 있다. 예를 들어 피보나치 수열을 일반적인 재귀 방식으로 구현하면 다음과 같다.

```js
function fibo(n) {
  if (n < 2) return n;

  return fibo(n - 1) + fibo(n - 2);
}
```

식으로 표현하면 다음과 같다. `f(n) = f(n - 1) + f(n - 2)`

그런데 아래의 그림을 보자. 동일한 값을 또다시 여러번 구하게 되는 과정을 반복하게 된다. 이렇게 되면 n이 커지면 커질수록 피보나치 수를 구하기 위해 호출되는 함수의 횟수는 기하급수 적으로 증가한다.

<div align="center">
<img src="https://velog.velcdn.com/images%2Fjusung-c%2Fpost%2F88d6ff9a-422e-45e9-af65-e57af2e19815%2Fimage.png" />
</div>

그러나 한 번 구한 작은 문제의 결과 값을 **저장**해두고 재사용한다면, 이미 계산된 값을 다시 반복할 필요가 없다. 즉, 시간복잡도를 효율적으로 개선이 가능하다! `O(N^2) -> O(f(N))`

- **이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.**
- 다이나믹 프로그래밍을 이용해서 시간복잡도를 획기적으로 줄일 수 있는 경우가 많다.

<br />

### 2. DP의 사용 조건

#### 1. **최적 부분 구조 (Optimal Substructure)**

: 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있을 때 사용할 수 있다. 즉, **부분 문제의 최적 결과값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**를 의미한다.

예) 최적 경로 찾기

#### 2. **중복되는 부분 문제 (Overlapping Subproblem)**

: **동일한 작은 문제를 반복적으로 해결해야 할 때 사용**할 수 있다.

예) 피보나치 수열, 이진 탐색

<br />

### 3. DP로 문제 풀이하기

#### 3-1. 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하기

가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토하고 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려한다.

현재 해결하려는 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지 판단해야 한다. 즉, 위에서 쓴 조건들이 충족되는 문제인지 체크한다. 보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.

#### 3-2. 문제의 변수 파악

DP는 현재 변수에 따라 그 결과값을 찾고 그것을 전달하여 재사용하는 것을 거친다. 즉, 문제 내 변수의 개수를 알아내야 한다.

예를 들어 피보나치 수열에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다.

#### 3-3. 변수 간 관계식 만들기

변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다.

이러한 식을 **점화식**이라고 부르며 DP 문제 해결의 핵심이다. 이를 통해 짧은 코드 내에서 반복 / 재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.

예를 들어 피보나치 수열에서는 `f(n) = f(n-1) + f(n-2)`가 점화식이라고 볼 수 있다.

#### 3-4. 메모하기

점화식을 성공적으로 세웠다면, 변수의 값에 따른 결과를 저장해야 한다. 이것을 메모한다고 하여 **메모이제이션(Memoization)**이라고 한다.

메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나로 **한 번 계산한 결과를 메모리 공간에 메모하는 기법**이다. 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다. 값을 기록해 놓는다는 점에서 **캐싱(Caching)**이라고도 한다. **이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미**하므로 다이나믹 프로그래밍에 국한된 개념은 아니다.

변수 값에 따른 결과를 저장할 배열(일반적으로 dp 혹은 d라고 배열명을 짓는 것 같다) 등을 미리 만들고 그 결과가 나올 때마다 배열에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결할 수 있다.

#### 3-5. 기저 상태 파악하기

이제 가장 작은 문제의 상태를 알아야 한다.

피보나치 수열을 예시로 들면, `f(0) = 0`, `f(1) = 1`과 같은 것을 말한다. 이후 두 가지 수를 더해가며 값을 구하지만 기본적으로 가장 작은 문제는 위 두가지이다.

이 값을 파악하고 미리 배열에 저장해두면 된다. 문제에 따라 파악하기 쉽지 않을 수도 있다.

#### 3-6. 구현하기

이제 구현만 하면 된다. 구현 방식은 아래에서 살펴보자.

<br />

### 4. DP구현 방식

#### 4-1. **Top-Down (하향식)**

- 구현 방식에서 **재귀 함수**를 사용한다.
- **큰 문제를 해결하기 위해서 작은 문제를 재귀적으로 호출하여 그 작은 문제들이 모두 해결되었을 때, 실제로 큰 문제에 대한 답까지 얻을 수 있도록 코드를 작성**한다.
- 그 과정에서 한 번 계산된 결과값을 기록하기 위해 **메모이제이션 기법**을 사용한다.

#### 4-2. **Bottom-Up (상향식)**

- **아래 쪽에서 부터 작은 문제를 하나씩 해결해나가면서, 먼저 계산한 문제들의 값을 활용하여 다음의 문제를 해결하는 것**이 특징이다.
- **반복문**을 사용해서 해결한다.
- 다이나믹 프로그래밍의 전형적인 형태는 bottom-up방식이고, 결과 저장용 배열은 **DP 테이블**이라고 부른다.

<br />

### 5. 대표 문제

#### 피보나치 수열

각각의 피보나치 수를 구할 때 앞의 두 수를 더한 값을 사용. 각각의 항이 인접한 항들과 관계에 의한 값일 경우 **점화식을 사용해서 인접한 항들 사이의 관계식**을 구할 수 있다.

> a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub>
> , a<sub>1</sub>=1, a<sub>2</sub>=1

- 수열을 배열이나 리스트를 이용해 표현
- **시간복잡도**
  - 단순 재귀로 구현 시 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 된다. $O(2^n)$
  - 동일한 부분 문제가 반복적으로 호출된다. (**중복되는 부분 문제**)
  - 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 $O(N)$
- 다이나믹 프로그래밍의 사용 조건을 만족하는지?
  - 최적 부분 구조와 중복되는 부분 문제 조건을 둘 다 만족

**Tob-down (하향식)**

```tsx
const dp = new Array(n + 1).fill(0);

const fibo = (n) => {
  if (n === 0) return 0;
  else if (n === 1) return 1;

  if (dp[n] !== 0) return dp[n];

  dp[n] = fibo(n - 1) + fibo(n - 2);
  return dp[n];
};

console.log(fibo(n));
```

**Bottom-up(상향식)**

```tsx
const dp = new Array(n + 1).fill(0);

dp[0] = 0;
dp[1] = 1;

for (let i = 2; i < n + 1; i++) {
  dp[i] = dp[i - 1] + dp[i - 2];
}

console.log(dp[n]);
```

<br />

### 6. 다이나믹 프로그래밍 vs 분할 정복

- 다이나믹 프로그래밍과 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용할 수 있다.
  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
- 다이나믹 프로그래밍과 분할 정복의 차이점은 **부분 문제의 중복**이다.
  - 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
  - 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.

<br />

**[⬆ Back to Top](#목차)**
