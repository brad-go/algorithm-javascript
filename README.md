# algorithm-javascript

알고리즘에 대해 공부하고 정리하며 문제 풀이들을 기록하는 저장소

## 목차

- [동적 계획법](#dynamic-programming-동적-계획법)

## Dynamic Programming (동적 계획법)

> **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**

- **이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.**
- 한번 계산하여 해결한 문제는 다시 해결하지 않도록 효율적으로 작성한다.
- 다이나믹 프로그래밍을 이용해서 시간복잡도를 획기적으로 줄일 수 있는 경우가 많다.

### 동적(Dynamic)이란?

- 자료구조에서 동적 할당(Dynamic Allocation)은 ‘**프로그램이 실행되는 도중에 실행한 메모리를 할당하는 기법**’
  → 메모리 공간이 필요할 때마다 필요한 만큼의 공간을 프로그램 실행 중에 할당하는 기법
- 반면에 **다이나믹 프로그래밍**에서 ‘다이나믹'은 별다른 의미 없이 사용된 단어

### 사용 조건

1. **최적 부분 구조 (Optimal Substructure)**

   큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있을 때

2. **중복되는 부분 문제 (Overlapping Subproblem)**

   동일한 작은 문제를 반복적으로 해결해야 할 때

### 구현 방식

1. **Top-Down (하향식)**
   - 구현 방식에서 재귀 함수를 사용한다.
   - 큰 문제를 해결하기 위해서 작은 문제를 재귀적으로 호출하여 그 작은 문제들이 모두 해결되었을 때, 실제로 큰 문제에 대한 답까지 얻을 수 있도록 코드를 작성한다.
   - 그 과정에서 한 번 계산된 결과값을 기록하기 위해 **메모이제이션 기법**을 사용한다.
2. **Bottom-Up (상향식)**
   - 아래 쪽에서 부터 작은 문제를 하나씩 해결해나가면서, 먼저 계산한 문제들의 값을 활용하여 다음의 문제를 해결하는 것이 특징이다.
   - 반복문을 사용해서 해결한다.
   - 다이나믹 프로그래밍의 전형적인 형태는 bottom-up방식이고, 결과 저장용 배열은 **DP 테이블**이라고 부른다.

<aside>

> 💡 **점화식을 세우는 것이 핵심!**

</aside>

### 메모이제이션 (Memoization)

다이나믹 프로그래밍을 구현하는 방법 중 하나로 **한 번 계산한 결과를 메모리 공간에 메모하는 기법**

- 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
- 값을 기록해 놓는다는 점에서 **캐싱(Caching)**이라고도 한다.
- **이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미**하므로 다이나믹 프로그래밍에 국한된 개념은 아니다.

### 대표 문제

#### 피보나치 수열

각각의 피보나치 수를 구할 때 앞의 두 수를 더한 값을 사용. 각각의 항이 인접한 항들과 관계에 의한 값일 경우 **점화식을 사용해서 인접한 항들 사이의 관계식**을 구할 수 있다.

> $a_n = a_n-1 + a_n-2$
> , $a_1 = 1$, $a_2 = 1$

- 수열을 배열이나 리스트를 이용해 표현
- **시간복잡도**
  - 단순 재귀로 구현 시 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 된다. $O(2^n)$
  - 동일한 부분 문제가 반복적으로 호출된다. (**중복되는 부분 문제**)
  - 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 $O(N)$
- 다이나믹 프로그래밍의 사용 조건을 만족하는지?
  - 최적 부분 구조와 중복되는 부분 문제 조건을 둘 다 만족

**Tob-down (하향식)**

```tsx
const dp = new Array(n + 1).fill(0);

const fibo = (n) => {
  if (n === 0) return 0;
  else if (n === 1) return 1;

  if (dp[n] !== 0) return dp[n];

  dp[n] = fibo(n - 1) + fibo(n - 2);
  return dp[n];
};

console.log(fibo(n));
```

**Bottom-up(상향식)**

```tsx
const dp = new Array(n + 1).fill(0);

dp[0] = 0;
dp[1] = 1;

for (let i = 2; i < n + 1; i++) {
  dp[i] = dp[i - 1] + dp[i - 2];
}

console.log(dp[n]);
```

### 다이나믹 프로그래밍 vs 분할 정복

- 다이나믹 프로그래밍과 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용할 수 있다.
  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
- 다이나믹 프로그래밍과 분할 정복의 차이점은 **부분 문제의 중복**이다.
  - 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
  - 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.

### 문제 접근 방법

- 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요하다.
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토하기
  - 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍 고려
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법 사용

<!-- ## Rule

### Solving

- 문제 당 최대 1시간까지 문제 풀이
- 실패한 문제는 다시 풀어보기

### Commite Message

#### Format

```
{ Keyword } : [{출처} {난이도}] {문제번호} {제목}
```

#### Keyword

- `Solve`: 풀이에 성공한 새 문제 추가
- `Fail`: 풀이에 실패한 새 문제 추가
- `Modify`: 기존 파일 수정 시
- `Remove`: 기존 파일 삭제 시
- `Docs`: 문서 수정 -->
